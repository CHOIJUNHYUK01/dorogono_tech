# 뉴스피드

뉴스 피드 앱을 만드는 건, 클래식하다. <br />
하지만 이걸 어떻게 디자인하는지 더 깊게 들어가 얘기를 하는 콘텐츠가 거의 없다시피 한다.

페이스북, 인스타그램, X, 레딧 등이 예시다.

---

## 요구사항

### 핵심 기능

1. 해당 유저와 친구가 만든 포스트를 포함해 보여준다. <br />
2. 포스트는 좋아요와 같은 리액션 기능이 있어야 한다. <br />
3. 포스트를 만들어 올릴 수 있어야 한다.

답글과 공유 기능은 후에 다룬다. 핵심 기능은 아니다.

### 어떤 포스트를 보여주는가

우선적으로 텍스트와 이미지 기반 포스트다.

### 어떤 페이지네이션 UX가 피드에 사용되나

인피니트 스크롤이 주로 쓰인다. <br />
유저가 그들의 마지막 피드에 도달했을 때, 새 포스트를 보여주는 방식이다.

### 모바일 기기에서도 사용될 것인가

우선 순위는 아니지만, 있으면 좋다.

---

## 아키텍쳐 / high-level 디자인

![architecture](https://www.greatfrontend.com/img/questions/news-feed-facebook/news-feed-architecture.png)

### 각 컴포넌트별 책임

- Server : <br />
  피드 포스트를 불러오고, 새 포스트를 올리는 HTTP API를 제공한다.

- Controller : <br />
  앱의 데이터 흐름을 제어하고, 서버에 데이터를 요청한다.

- Client Store: <br />
  앱 전반에 걸쳐 필요한 데이터를 저장한다. <br />
  뉴스 피드의 맥락에서, 여기에 저장된 대부분의 데이터는 피드 UI에 필요한 서버에서 발생한 데이터다.

- Feed UI: <br />
  피드 포스트 목록을 포함한다. <br />
  새 게시물을 작성하기 위한 UI도 포함한다.

  1. Feed Post <br />
     피드 게시물의 데이터를 표시한다. <br />
     게시물과 상호작용할 수 있는 버튼을 포함한다.

  2. Post Composer <br />
     WYSIWYG 에디터를 제공한다. <br />
     WYSIWYG는 "What You See Is What You Get"의 약자다. <br />
     즉, "보이는 대로 얻게 해주는 편집기"라고 보면 된다.

### 렌더링 접근 방식

어디서 콘텐츠를 로딩할지, 서버 아니면 클라이언트에서 할지 결정할 수 있다.

- SSR (Server-Side Rendering) <br />
  서버 측에서 HTML을 렌더링하는 전통적인 방법이 있다. <br />
  SEO에 최적이고, 정적인 콘텐츠를 제공하거나 상호작용이 적다면 최적이다. <br />
  블로그, 문서, 쇼핑몰 페이지같은 게 여기에 속한다.

- CSR (Client-Side Rendering) <br />
  브라우저에서 렌더링한다. <br />
  JavaScript를 사용해, 동적으로 DOM 요소를 추가한다. <br />
  상호작용이 많은 콘텐츠에 최적이다. <br />
  대시보드 앱, 채팅 앱 등이 여기에 속한다.

뉴스 피드 앱은 이 둘 사이 어딘가에 속한다. <br />
정적인 콘텐츠도 많지만, 상호작용도 그에 맞게 많이 존재한다.

실제로, 페이스북은 하이브리드 접근을 한다. <br />
일단 SSR로 초기 로딩을 빠르게 한다. <br />
그 후에 상호작용을 할 수 있게 만든다. <br />
유저가 페이지 끝에 도달해서 새 뉴스 피드가 추가된다면, 그건 CSR을 사용하는 거다.

React와 Vue 같은 현대적인 UI JavaScript 프레임워크들과, Next.js와 Nuxt와 같은 메타 프레임워크들이 이러한 렌더링 전략을 지원한다.

[웹 랜더링 방식](https://web.dev/articles/rendering-on-the-web?hl=ko) <br />
[Meta가 채택한 방식](https://engineering.fb.com/2020/05/08/web/facebook-redesign/)

---

## 데이터 모델

뉴스 피드는 포스트 목록을 서버로부터 받아와 보여준다. <br />
앱의 거의 모든 데이터는 서버에서 만들어진 데이터이기 때문이다. <br />
유일한 클라이언트 측의 데이터는 "게시물 작성기"에 사용되는 형식이다.

| 사용 주체 | 자원 위치          | 속하는 곳        | 사용 데이터                                                 |
| --------- | ------------------ | ---------------- | ----------------------------------------------------------- |
| Feed      | Server             | Feed UI          | posts, pagination metadata                                  |
| Post      | Server             | Feed Post        | id, created_time, content, author 등 포스트에 포함된 데이터 |
| User      | Server             | Client Store     | id, name, profile_photo_url 등 개인정보                     |
| NewPost   | User input(Client) | Post Composer UI | message, image 등 게시물 작성에 필요한 데이터               |

### Advanced: Normalized store

페이스북과 트위터는 정규화된 client side store를 사용한다. <br />
"정규화"라는 단어가 새로울 수 있다. <br />
그렇다면, [Redux 문서](https://redux.js.org/usage/structuring-reducers/normalizing-state-shape)를 읽길 바란다. <br />
간단히 말해서, 정규화된 데이터 스토어의 특징은 다음과 같다.

- 데이터베이스와 유사한 구조를 갖는다. <br />
  각 데이터 타입이 자신만의 "테이블"에 저장된다. <br />
  마치 실제 데이터베이스처럼 말이다.

- 각 아이템은 고유한 ID를 가진다.

- ID를 통해(외부키와 같이) 중첩된 객체 대신, 다른 데이터 타입을 참조한다.

페이스북은 `Relay`(GraphQL 라이브러리)를 사용한다. <br />
트위터는 `Redux`를 사용한다. [트위터의 리덕스 사용기](https://medium.com/statuscode/dissecting-twitters-redux-store-d7280b62c6b1)

### 정규화된 스토어의 이점

1. 중복 데이터 감소 <br />
   UI의 여러 곳에서 표시될 수 있는 동일한 데이터에 대해 단일성을 가진다. <br />
   예를 들어, 여러 게시물이 같은 작성자에 의해 작성된 경우를 생각해보자. <br />

   ```javascript
   <!-- 정규화 이전 -->
   let posts = [
     { id: 1, author: { id: 1, name: "Kim", avatar: "url1" } },
     { id: 2, author: { id: 1, name: "Kim", avatar: "url1" } },
     { id: 3, author: { id: 1, name: "Kim", avatar: "url1" } },
   ];

    <!-- 정규화 이후 -->
   let authors = {
       1: { id: 1, name: "Kim", avatar: "url1" },
     },
     posts: {
       1: { id: 1, authorId: 1 },
       2: { id: 2, authorId: 1 },
       3: { id: 3, authorId: 1 },
     };
   ```

   이렇게 정규화를 하면서, 작성자 정보가 한 번만 저장되게 한다. <br />
   데이터 업데이트도 용이해지고, 메모리 사용이 효율적이게 된다. <br />
   데이터 일관성 유지가 쉬워진다.

2. 동일 엔티티의 데이터를 쉽게 업데이트할 수 있다. <br />
   피드 포스트에 사용자가 작성한 많은 게시물이 있고, 해당 사용자가 이름을 변경한다고 해보자. <br />
   UI에서 업데이트된 작성자 이름을 즉시 반영할 수 있으면 좋다. <br />
   이는 서버 응답을 그대로 저장하는 스토어보다 정규화된 스토어를 사용하면 더 쉽게 할 수 있다.

뉴스 피드에는 정규화된 스토어를 사용할 필요가 없다. <br />
사용자 및 작성자 필드를 제외하면 중복된 데이터가 많지 않다. <br />
뉴스 피드는 주로 정보를 소비하는 용도이며, 데이터를 업데이트하는 사용 사례가 많지 않다. <br />
좋아요와 같은 피드 사용자 상호작용은 피드 게시물 내의 데이터에만 영향을 미친다.

따라서 정규화된 스토어를 사용하는 장점은 제한적이다. <br />
실제로는 페이스북과 트위터 웹사이트에는 정규화된 스토어가 제공하는 기능의 혜택을 받는 다른 많은 기능이 포함되어 있다.

---

## 인터페이스 정의 (API)

| Source        | Destination | API type   | Functionality                   |
| ------------- | ----------- | ---------- | ------------------------------- |
| Server        | Controller  | HTTP       | Fetch feed posts                |
| Controller    | Server      | HTTP       | Create new post                 |
| Controller    | Feed UI     | JavaScript | Pass feed posts data, Reactions |
| Post composer | Controller  | JavaScript | Pass new post data              |

피드 포스트 목록을 불러오는 HTTP API가 가장 흥미로운 부분이다. <br />
페이지네이션 접근 방식은 논의할 가치가 있다.

| Field       | Value                                |
| ----------- | ------------------------------------ |
| HTTP Method | GET                                  |
| Path        | /feed                                |
| Description | Fetches the feed results for a user. |

페이지네이션된 콘텐츠를 받는 두 가지 방법이 있다. <br />
각각 방법에는 장단점이 있다.

## Offset-based 페이지네이션

오프셋 기반 페이지네이션은 데이터를 가져오기 시작할 위치를 지정하는 `오프셋`과 가져올 항목 수를 지정하는 `limit`을 사용한다. <br />
"10번 째 레코드부터 다음 5개 항목을 주세요"라고 말하는 것과 같다. <br />
오프셋은 명시적인 숫자 혹은 요청된 페이지 번호로 변환될 수 있다. <br />
페이지 크기가 5인 3번 째 페이지를 요청하면 오프셋은 10이 된다. <br />
일반적으로 오프셋 기반 페이지 기반 페이지네이션 API는 `page` 파라미터를 받고, 서버가 데이터베이스 쿼리 시, 이를 오프셋 값으로 변환한다.

| Parameter | Type   | Description        |
| --------- | ------ | ------------------ |
| size      | number | 페이지당 항목 수   |
| page      | number | 가져올 페이지 번호 |

피드에 이미 20개 항목이 있고, `{size: 5, page: 2}`의 파리미터는 6~10번 항목과 함께 페이지네이션 메타데이터를 반환한다.

```javascript
{
  "pagination": {
    "size": 5,
    "page": 2,
    "total_pages": 4,
    "total": 20
  },
  "results": [
    {
      "id": "123",
      "author": {
        "id": "456",
        "name": "John Doe"
      },
      "content": "Hello world",
      "image": "https://www.example.com/feed-images.jpg",
      "reactions": {
        "likes": 20,
        "haha": 15
      },
      "created_time": 1620639583
    }
    // ... 더 많은 게시물
  ]
}
```

SQL 쿼리 예시는 아래와 같다.

```sql
SELECT * FROM posts LIMIT 5 OFFSET 0; -- 첫 번째 페이지
SELECT * FROM posts LIMIT 5 OFFSET 5; -- 두 번째 페이지
```

### 장점

1. 사용자가 특정 페이지로 직접 이동할 수 있다. <br />
2. 전체 페이지 수를 쉽게 확인할 수 있다. <br />
3. 백엔드 구현이 쉽고, SQL 쿼리의 `OFFSET` 값은 `(page - 1) * size`로 계산한다. <br />
4. 다양한 데이터베이스 시스템에서 쉽게 사용이 가능하며, 특정 데이터 저장 매커니즘에 종속되지 않는다.

### 단점

1. 부정확한 페이지 결과 <br />
   자주 업데이트되는 데이터의 경우, 시간이 지난 후에 현재 페이지 창이 부정확해질 수 있다. <br />
   사용자가 피드의 첫 5개 게시물을 가져왔다고 해보자. <br />
   시간이 지난 후, 5개의 게시물이 더 추가됐다. <br />
   사용자가 피드 하단으로 스크롤해서 2페이지를 가져오면, 원래 1페이지에 있던 동일한 게시물도 응답에 포함된다. <br />
   그렇게 중복된 게시물을 보게 된다.

```
// Initial posts (newest on the left, oldest on the right)
Posts: A, B, C, D, E, F, G, H, I, J
       ^^^^^^^^^^^^^ Page 1 contains A - E

// New posts added over time
Posts: K, L, M, N, O, A, B, C, D, E, F, G, H, I, J
                      ^^^^^^^^^^^^^ Page 2 also contains A - E
```

클라이언트는 이미 표시된 게시물을 보여주지 않는 방식으로 중복 제거하길 원할 수도 있다. <br />
하지만 이는 사용자 정의 로직이 필요하고, 부족한 새 게시물을 보충하기 위해 새로운 요청을 해야 하므로, 추가적인 네트워크 왕복이 발생한다. <br />
항목 수가 시간이 지남에 따라 줄어들 수 있는 사용 사례의 경우, 페이지에서 일부 항목이 누락될 수 있다.

2. 페이지 크기를 쉽게 변경할 수 없음 <br />
   오프셋 기반 페이지네이션의 또 다른 단점은 오프셋이 페이지 크기와 요청된 페이지의 곱이기 때문에 클라이언트가 후속 쿼리에 대한 페이지 크기를 변경할 수 없다는 것이다.

| 페이지 | 페이지 크기 | 결과        |
| ------ | ----------- | ----------- |
| 1      | 5           | 항목 1 - 5  |
| 2      | 5           | 항목 6 - 10 |
| 2      | 7           | 항목 8 - 14 |

위 예시에서 클라이언트가 `{page:1, size: 5}`에서 `{page:2, size:7}`로 변경하면, 항목 6과 7을 놓치게 된다.

3. 시간이 지날수록 쿼리 성능 저하 <br />
   테이블이 커질수록 쿼리 성능이 저하된다. <br />
   큰 오프셋의 경우, 데이터베이스는 여전히 해당 `count + offset` 행까지 읽어야 한다. <br />
   `offset` 행을 버리고 `count` 행만 반환해야 하므로, 큰 오프셋에 대해 매우 나쁜 쿼리 성능이 발생한다.

### 결론

오프셋 기반 페이지네이션은 특정 페이지로 이동이 필요하다. <br />
결과가 너무 빠르게 업데이트되지 않는 검색 결과와 같은 목록을 표시하는 웹 애플리케이션에서 일반적이다. <br />
따라서, 블로그나 여행 예약 웹사이트, 전자상거래 웹사이트는 검색 결과에 이를 사용하는 것이 유리하다.

---

## 커서 기반 페이지네이션

이는 데잍터셋의 특정 레코드를 가리키는 포인터(커서)를 사용한다. <br />
"11번부터 15번 항목을 줘"라는 것 대신에 "[특정 항목] 이후부터 5개 항목을 줘"라고 요청하는 방식이다. <br />
커서는 보통 고유 식별자로, `항목ID`, `타임스탬프` 또는 다른 것이 될 수 있다. <br />
후속 요청은 마지막 항목의 식별자를 커서로 사용해 다음 항목을 가져온다.

커서 기반 페이지네이션 API는 파라미터와 응답은 아래와 같다.

```sql
SELECT * FROM table WHERE id > cursor LIMIT 5
```

| Parameter | Type   | Description                                                             |
| --------- | ------ | ----------------------------------------------------------------------- |
| size      | number | 페이지당 결과 수                                                        |
| cursor    | string | 마지막으로 가져온 항목의 식별자. 데이터베이스 쿼리가 이 식별자를 사용함 |

```javascript
{
  "pagination": {
    "size": 10,
    "next_cursor": "=dXNlcjpVMEc5V0ZYTlo"
  },
  "results": [
    {
      "id": "123",
      "author": {
        "id": "456",
        "name": "John Doe"
      },
      "content": "Hello world",
      "image": "https://www.example.com/feed-images.jpg",
      "reactions": {
        "likes": 20,
        "haha": 15
      },
      "created_time": 1620639583
    }
    // ... More posts.
  ]
}

```

### 장점

1. 대규모 데이터셋에서 더 효율적이고 빠르다. <br />
2. 시간이 지나면서 추가되는 새 게시물이 고정된 커서에 의해 결정되는 오프셋에 영향을 미치지 않는다. <br />
   그래서 부정확한 페이지 창 문제를 피할 수 있다. <br />
   실시간 데이터에 적합하다.

```
// 초기 상태
Posts: [A, B, C, D, E, F, G, H]
첫 요청: "Give me 3 items" → [A, B, C], cursor: C의 ID

// 새 게시물 X, Y 추가됨
Posts: [X, Y, A, B, C, D, E, F, G, H]
다음 요청: "Give me 3 items after C" → [D, E, F]
// 새 게시물이 추가되어도 C 이후의 항목을 정확히 가져올 수 있음
```

이런 방식으로 커서 기반 페이지네이션은 실시간으로 업데이트되는 피드에서 발생할 수 있는 데이터 중복이나 누락 문제를 해결한다.

### 단점

1. 클라이언트가 커서를 모르기 때문에 이전 페이지들을 거치지 않고는 특정 페이지로 직접 이동이 불가하다. <br />
2. 오프셋 기반 페이지네이션에 비해 구현이 약간 더 복잡하다. <br />
3. 백엔드에서 커서 기반 페이지네이션을 구현하려면, 데이터베이스가 커서를 고유하게 행에 매핑해야 한다. <br />
   (데이터베이스 테이블의 기본 키나 타임스탬프 사용)

---

## 뉴스피드에선 뭘 사용해야 할까?

오프셋 기반과 커서 기반 페이지네이션 중 선택은 데이터와 요구사항에 좌우된다.

- 오프셋 기반 : 정적이거나 작은 데이터셋에서 페이지 직접 접근이 중요할 때, 더 단순하고 좋다. <br />
- 커서 기반 : 데이터 순서가 중요하고, 자주 변경되는 큰 동적 데이터셋에 더 효율적이고 신뢰할 수 있다.

### 무한 스크롤 뉴스 피드의 특징

1. 새 게시물이 피드 상단에 자주 추가될 수 있다. <br />
2. 새로 가져온 게시물이 피드 끝에 추가된다. <br />
3. 테이블 크기가 빠르게 증가할 수 있다.

따라서 뉴스 피드에는 `커서 기반 페이지네이션`이 더 우수하며, 사용되어야 한다.

### 포스트 생성

해당 HTTP 메서드는 유저가 새 포스트를 만들기 위함이다. <br />
그들 개인 포스트와 그들의 친구 포스트도 보여져야 한다.

| Field       | Value                         |
| ----------- | ----------------------------- |
| HTTP Method | POST                          |
| Path        | /posts                        |
| Description | 새 게시물 생성                |
| Parameters  | { body: '...', media: '...' } |

HTTP API의 파라미터는 생성되는 게시물의 유형에 따라 달라진다. <br />
대부분의 경우에는 인터뷰에서 핵심 논의 사항이 아니다. <br />
응답 형식은 단일 게시물이나 피드의 최신 게시물 목록일 수 있다. <br />
단일 게시물이 반환되는 경우, API 응답은 피드 API 내의 피드 게시물 항목과 유사하다.

```javascript
{
  "id": "124",
  "author": {
    "id": "456",
    "name": "John Doe"
  },
  "content": "Hello world",
  "image": {
    "src": "https://www.example.com/feed-images.jpg",
    "alt": "An image alt", // 사용자 제공 또는 서버에서 생성
    // 크기 등 다른 유용한 속성들도 포함될 수 있음
  },
  "reactions": {
    "likes": 20,
    "haha": 15
  },
  "created_time": 1620639583
}
```

이런 새 게시물 데이터가 주어지면, 클라이언트 스토어는 이를 피드 목록의 시작 부분에 추가해야 한다. <br />
이런 방식으로 실시간 업데이트가 많은 뉴스 피드에서 `커서 기반 페이지네이션`을 사용하면, 데이터 일관성과 사용자 경험을 모두 개선할 수 있다.

---
