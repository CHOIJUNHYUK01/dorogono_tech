# 뉴스피드

뉴스 피드 앱을 만드는 건, 클래식하다. <br />
하지만 이걸 어떻게 디자인하는지 더 깊게 들어가 얘기를 하는 콘텐츠가 거의 없다시피 한다.

페이스북, 인스타그램, X, 레딧 등이 예시다.

---

## 요구사항

### 핵심 기능

1. 해당 유저와 친구가 만든 포스트를 포함해 보여준다. <br />
2. 포스트는 좋아요와 같은 리액션 기능이 있어야 한다. <br />
3. 포스트를 만들어 올릴 수 있어야 한다.

답글과 공유 기능은 후에 다룬다. 핵심 기능은 아니다.

### 어떤 포스트를 보여주는가

우선적으로 텍스트와 이미지 기반 포스트다.

### 어떤 페이지네이션 UX가 피드에 사용되나

인피니트 스크롤이 주로 쓰인다. <br />
유저가 그들의 마지막 피드에 도달했을 때, 새 포스트를 보여주는 방식이다.

### 모바일 기기에서도 사용될 것인가

우선 순위는 아니지만, 있으면 좋다.

---

## 아키텍쳐 / high-level 디자인

![architecture](https://www.greatfrontend.com/img/questions/news-feed-facebook/news-feed-architecture.png)

### 각 컴포넌트별 책임

- Server : <br />
  피드 포스트를 불러오고, 새 포스트를 올리는 HTTP API를 제공한다.

- Controller : <br />
  앱의 데이터 흐름을 제어하고, 서버에 데이터를 요청한다.

- Client Store: <br />
  앱 전반에 걸쳐 필요한 데이터를 저장한다. <br />
  뉴스 피드의 맥락에서, 여기에 저장된 대부분의 데이터는 피드 UI에 필요한 서버에서 발생한 데이터다.

- Feed UI: <br />
  피드 포스트 목록을 포함한다. <br />
  새 게시물을 작성하기 위한 UI도 포함한다.

  1. Feed Post <br />
     피드 게시물의 데이터를 표시한다. <br />
     게시물과 상호작용할 수 있는 버튼을 포함한다.

  2. Post Composer <br />
     WYSIWYG 에디터를 제공한다. <br />
     WYSIWYG는 "What You See Is What You Get"의 약자다. <br />
     즉, "보이는 대로 얻게 해주는 편집기"라고 보면 된다.

### 렌더링 접근 방식

어디서 콘텐츠를 로딩할지, 서버 아니면 클라이언트에서 할지 결정할 수 있다.

- SSR (Server-Side Rendering) <br />
  서버 측에서 HTML을 렌더링하는 전통적인 방법이 있다. <br />
  SEO에 최적이고, 정적인 콘텐츠를 제공하거나 상호작용이 적다면 최적이다. <br />
  블로그, 문서, 쇼핑몰 페이지같은 게 여기에 속한다.

- CSR (Client-Side Rendering) <br />
  브라우저에서 렌더링한다. <br />
  JavaScript를 사용해, 동적으로 DOM 요소를 추가한다. <br />
  상호작용이 많은 콘텐츠에 최적이다. <br />
  대시보드 앱, 채팅 앱 등이 여기에 속한다.

뉴스 피드 앱은 이 둘 사이 어딘가에 속한다. <br />
정적인 콘텐츠도 많지만, 상호작용도 그에 맞게 많이 존재한다.

실제로, 페이스북은 하이브리드 접근을 한다. <br />
일단 SSR로 초기 로딩을 빠르게 한다. <br />
그 후에 상호작용을 할 수 있게 만든다. <br />
유저가 페이지 끝에 도달해서 새 뉴스 피드가 추가된다면, 그건 CSR을 사용하는 거다.

React와 Vue 같은 현대적인 UI JavaScript 프레임워크들과, Next.js와 Nuxt와 같은 메타 프레임워크들이 이러한 렌더링 전략을 지원한다.

[웹 랜더링 방식](https://web.dev/articles/rendering-on-the-web?hl=ko) <br />
[Meta가 채택한 방식](https://engineering.fb.com/2020/05/08/web/facebook-redesign/)

---

## 데이터 모델

뉴스 피드는 포스트 목록을 서버로부터 받아와 보여준다. <br />
앱의 거의 모든 데이터는 서버에서 만들어진 데이터이기 때문이다. <br />
유일한 클라이언트 측의 데이터는 "게시물 작성기"에 사용되는 형식이다.

| 사용 주체 | 자원 위치          | 속하는 곳        | 사용 데이터                                                 |
| --------- | ------------------ | ---------------- | ----------------------------------------------------------- |
| Feed      | Server             | Feed UI          | posts, pagination metadata                                  |
| Post      | Server             | Feed Post        | id, created_time, content, author 등 포스트에 포함된 데이터 |
| User      | Server             | Client Store     | id, name, profile_photo_url 등 개인정보                     |
| NewPost   | User input(Client) | Post Composer UI | message, image 등 게시물 작성에 필요한 데이터               |

### Advanced: Normalized store

페이스북과 트위터는 정규화된 client side store를 사용한다. <br />
"정규화"라는 단어가 새로울 수 있다. <br />
그렇다면, [Redux 문서](https://redux.js.org/usage/structuring-reducers/normalizing-state-shape)를 읽길 바란다. <br />
간단히 말해서, 정규화된 데이터 스토어의 특징은 다음과 같다.

- 데이터베이스와 유사한 구조를 갖는다. <br />
  각 데이터 타입이 자신만의 "테이블"에 저장된다. <br />
  마치 실제 데이터베이스처럼 말이다.

- 각 아이템은 고유한 ID를 가진다.

- ID를 통해(외부키와 같이) 중첩된 객체 대신, 다른 데이터 타입을 참조한다.

페이스북은 `Relay`(GraphQL 라이브러리)를 사용한다. <br />
트위터는 `Redux`를 사용한다. [트위터의 리덕스 사용기](https://medium.com/statuscode/dissecting-twitters-redux-store-d7280b62c6b1)

### 정규화된 스토어의 이점

1. 중복 데이터 감소 <br />
   UI의 여러 곳에서 표시될 수 있는 동일한 데이터에 대해 단일성을 가진다. <br />
   예를 들어, 여러 게시물이 같은 작성자에 의해 작성된 경우를 생각해보자. <br />

   ```javascript
   <!-- 정규화 이전 -->
   let posts = [
     { id: 1, author: { id: 1, name: "Kim", avatar: "url1" } },
     { id: 2, author: { id: 1, name: "Kim", avatar: "url1" } },
     { id: 3, author: { id: 1, name: "Kim", avatar: "url1" } },
   ];

    <!-- 정규화 이후 -->
   let authors = {
       1: { id: 1, name: "Kim", avatar: "url1" },
     },
     posts: {
       1: { id: 1, authorId: 1 },
       2: { id: 2, authorId: 1 },
       3: { id: 3, authorId: 1 },
     };
   ```

   이렇게 정규화를 하면서, 작성자 정보가 한 번만 저장되게 한다. <br />
   데이터 업데이트도 용이해지고, 메모리 사용이 효율적이게 된다. <br />
   데이터 일관성 유지가 쉬워진다.

2. 동일 엔티티의 데이터를 쉽게 업데이트할 수 있다. <br />
   피드 포스트에 사용자가 작성한 많은 게시물이 있고, 해당 사용자가 이름을 변경한다고 해보자. <br />
   UI에서 업데이트된 작성자 이름을 즉시 반영할 수 있으면 좋다. <br />
   이는 서버 응답을 그대로 저장하는 스토어보다 정규화된 스토어를 사용하면 더 쉽게 할 수 있다.

뉴스 피드에는 정규화된 스토어를 사용할 필요가 없다. <br />
사용자 및 작성자 필드를 제외하면 중복된 데이터가 많지 않다. <br />
뉴스 피드는 주로 정보를 소비하는 용도이며, 데이터를 업데이트하는 사용 사례가 많지 않다. <br />
좋아요와 같은 피드 사용자 상호작용은 피드 게시물 내의 데이터에만 영향을 미친다.

따라서 정규화된 스토어를 사용하는 장점은 제한적이다. <br />
실제로는 페이스북과 트위터 웹사이트에는 정규화된 스토어가 제공하는 기능의 혜택을 받는 다른 많은 기능이 포함되어 있다.

---

## 인터페이스 정의 (API)

| Source        | Destination | API type   | Functionality                   |
| ------------- | ----------- | ---------- | ------------------------------- |
| Server        | Controller  | HTTP       | Fetch feed posts                |
| Controller    | Server      | HTTP       | Create new post                 |
| Controller    | Feed UI     | JavaScript | Pass feed posts data, Reactions |
| Post composer | Controller  | JavaScript | Pass new post data              |

피드 포스트 목록을 불러오는 HTTP API가 가장 흥미로운 부분이다. <br />
페이지네이션 접근 방식은 논의할 가치가 있다.

| Field       | Value                                |
| ----------- | ------------------------------------ |
| HTTP Method | GET                                  |
| Path        | /feed                                |
| Description | Fetches the feed results for a user. |

페이지네이션된 콘텐츠를 받는 두 가지 방법이 있다. <br />
각각 방법에는 장단점이 있다.

## Offset-based 페이지네이션

오프셋 기반 페이지네이션은 데이터를 가져오기 시작할 위치를 지정하는 `오프셋`과 가져올 항목 수를 지정하는 `limit`을 사용한다. <br />
"10번 째 레코드부터 다음 5개 항목을 주세요"라고 말하는 것과 같다. <br />
오프셋은 명시적인 숫자 혹은 요청된 페이지 번호로 변환될 수 있다. <br />
페이지 크기가 5인 3번 째 페이지를 요청하면 오프셋은 10이 된다. <br />
일반적으로 오프셋 기반 페이지 기반 페이지네이션 API는 `page` 파라미터를 받고, 서버가 데이터베이스 쿼리 시, 이를 오프셋 값으로 변환한다.

| Parameter | Type   | Description        |
| --------- | ------ | ------------------ |
| size      | number | 페이지당 항목 수   |
| page      | number | 가져올 페이지 번호 |

피드에 이미 20개 항목이 있고, `{size: 5, page: 2}`의 파리미터는 6~10번 항목과 함께 페이지네이션 메타데이터를 반환한다.

```javascript
{
  "pagination": {
    "size": 5,
    "page": 2,
    "total_pages": 4,
    "total": 20
  },
  "results": [
    {
      "id": "123",
      "author": {
        "id": "456",
        "name": "John Doe"
      },
      "content": "Hello world",
      "image": "https://www.example.com/feed-images.jpg",
      "reactions": {
        "likes": 20,
        "haha": 15
      },
      "created_time": 1620639583
    }
    // ... 더 많은 게시물
  ]
}
```

SQL 쿼리 예시는 아래와 같다.

```sql
SELECT * FROM posts LIMIT 5 OFFSET 0; -- 첫 번째 페이지
SELECT * FROM posts LIMIT 5 OFFSET 5; -- 두 번째 페이지
```

### 장점

1. 사용자가 특정 페이지로 직접 이동할 수 있다. <br />
2. 전체 페이지 수를 쉽게 확인할 수 있다. <br />
3. 백엔드 구현이 쉽고, SQL 쿼리의 `OFFSET` 값은 `(page - 1) * size`로 계산한다. <br />
4. 다양한 데이터베이스 시스템에서 쉽게 사용이 가능하며, 특정 데이터 저장 매커니즘에 종속되지 않는다.

### 단점

1. 부정확한 페이지 결과 <br />
   자주 업데이트되는 데이터의 경우, 시간이 지난 후에 현재 페이지 창이 부정확해질 수 있다. <br />
   사용자가 피드의 첫 5개 게시물을 가져왔다고 해보자. <br />
   시간이 지난 후, 5개의 게시물이 더 추가됐다. <br />
   사용자가 피드 하단으로 스크롤해서 2페이지를 가져오면, 원래 1페이지에 있던 동일한 게시물도 응답에 포함된다. <br />
   그렇게 중복된 게시물을 보게 된다.

```
// Initial posts (newest on the left, oldest on the right)
Posts: A, B, C, D, E, F, G, H, I, J
       ^^^^^^^^^^^^^ Page 1 contains A - E

// New posts added over time
Posts: K, L, M, N, O, A, B, C, D, E, F, G, H, I, J
                      ^^^^^^^^^^^^^ Page 2 also contains A - E
```

클라이언트는 이미 표시된 게시물을 보여주지 않는 방식으로 중복 제거하길 원할 수도 있다. <br />
하지만 이는 사용자 정의 로직이 필요하고, 부족한 새 게시물을 보충하기 위해 새로운 요청을 해야 하므로, 추가적인 네트워크 왕복이 발생한다. <br />
항목 수가 시간이 지남에 따라 줄어들 수 있는 사용 사례의 경우, 페이지에서 일부 항목이 누락될 수 있다.

2. 페이지 크기를 쉽게 변경할 수 없음 <br />
   오프셋 기반 페이지네이션의 또 다른 단점은 오프셋이 페이지 크기와 요청된 페이지의 곱이기 때문에 클라이언트가 후속 쿼리에 대한 페이지 크기를 변경할 수 없다는 것이다.

| 페이지 | 페이지 크기 | 결과        |
| ------ | ----------- | ----------- |
| 1      | 5           | 항목 1 - 5  |
| 2      | 5           | 항목 6 - 10 |
| 2      | 7           | 항목 8 - 14 |

위 예시에서 클라이언트가 `{page:1, size: 5}`에서 `{page:2, size:7}`로 변경하면, 항목 6과 7을 놓치게 된다.

3. 시간이 지날수록 쿼리 성능 저하 <br />
   테이블이 커질수록 쿼리 성능이 저하된다. <br />
   큰 오프셋의 경우, 데이터베이스는 여전히 해당 `count + offset` 행까지 읽어야 한다. <br />
   `offset` 행을 버리고 `count` 행만 반환해야 하므로, 큰 오프셋에 대해 매우 나쁜 쿼리 성능이 발생한다.

### 결론

오프셋 기반 페이지네이션은 특정 페이지로 이동이 필요하다. <br />
결과가 너무 빠르게 업데이트되지 않는 검색 결과와 같은 목록을 표시하는 웹 애플리케이션에서 일반적이다. <br />
따라서, 블로그나 여행 예약 웹사이트, 전자상거래 웹사이트는 검색 결과에 이를 사용하는 것이 유리하다.

---

## 커서 기반 페이지네이션

이는 데잍터셋의 특정 레코드를 가리키는 포인터(커서)를 사용한다. <br />
"11번부터 15번 항목을 줘"라는 것 대신에 "[특정 항목] 이후부터 5개 항목을 줘"라고 요청하는 방식이다. <br />
커서는 보통 고유 식별자로, `항목ID`, `타임스탬프` 또는 다른 것이 될 수 있다. <br />
후속 요청은 마지막 항목의 식별자를 커서로 사용해 다음 항목을 가져온다.

커서 기반 페이지네이션 API는 파라미터와 응답은 아래와 같다.

```sql
SELECT * FROM table WHERE id > cursor LIMIT 5
```

| Parameter | Type   | Description                                                             |
| --------- | ------ | ----------------------------------------------------------------------- |
| size      | number | 페이지당 결과 수                                                        |
| cursor    | string | 마지막으로 가져온 항목의 식별자. 데이터베이스 쿼리가 이 식별자를 사용함 |

```javascript
{
  "pagination": {
    "size": 10,
    "next_cursor": "=dXNlcjpVMEc5V0ZYTlo"
  },
  "results": [
    {
      "id": "123",
      "author": {
        "id": "456",
        "name": "John Doe"
      },
      "content": "Hello world",
      "image": "https://www.example.com/feed-images.jpg",
      "reactions": {
        "likes": 20,
        "haha": 15
      },
      "created_time": 1620639583
    }
    // ... More posts.
  ]
}

```

### 장점

1. 대규모 데이터셋에서 더 효율적이고 빠르다. <br />
2. 시간이 지나면서 추가되는 새 게시물이 고정된 커서에 의해 결정되는 오프셋에 영향을 미치지 않는다. <br />
   그래서 부정확한 페이지 창 문제를 피할 수 있다. <br />
   실시간 데이터에 적합하다.

```
// 초기 상태
Posts: [A, B, C, D, E, F, G, H]
첫 요청: "Give me 3 items" → [A, B, C], cursor: C의 ID

// 새 게시물 X, Y 추가됨
Posts: [X, Y, A, B, C, D, E, F, G, H]
다음 요청: "Give me 3 items after C" → [D, E, F]
// 새 게시물이 추가되어도 C 이후의 항목을 정확히 가져올 수 있음
```

이런 방식으로 커서 기반 페이지네이션은 실시간으로 업데이트되는 피드에서 발생할 수 있는 데이터 중복이나 누락 문제를 해결한다.

### 단점

1. 클라이언트가 커서를 모르기 때문에 이전 페이지들을 거치지 않고는 특정 페이지로 직접 이동이 불가하다. <br />
2. 오프셋 기반 페이지네이션에 비해 구현이 약간 더 복잡하다. <br />
3. 백엔드에서 커서 기반 페이지네이션을 구현하려면, 데이터베이스가 커서를 고유하게 행에 매핑해야 한다. <br />
   (데이터베이스 테이블의 기본 키나 타임스탬프 사용)

---

## 뉴스피드에선 뭘 사용해야 할까?

오프셋 기반과 커서 기반 페이지네이션 중 선택은 데이터와 요구사항에 좌우된다.

- 오프셋 기반 : 정적이거나 작은 데이터셋에서 페이지 직접 접근이 중요할 때, 더 단순하고 좋다. <br />
- 커서 기반 : 데이터 순서가 중요하고, 자주 변경되는 큰 동적 데이터셋에 더 효율적이고 신뢰할 수 있다.

### 무한 스크롤 뉴스 피드의 특징

1. 새 게시물이 피드 상단에 자주 추가될 수 있다. <br />
2. 새로 가져온 게시물이 피드 끝에 추가된다. <br />
3. 테이블 크기가 빠르게 증가할 수 있다.

따라서 뉴스 피드에는 `커서 기반 페이지네이션`이 더 우수하며, 사용되어야 한다.

### 포스트 생성

해당 HTTP 메서드는 유저가 새 포스트를 만들기 위함이다. <br />
그들 개인 포스트와 그들의 친구 포스트도 보여져야 한다.

| Field       | Value                         |
| ----------- | ----------------------------- |
| HTTP Method | POST                          |
| Path        | /posts                        |
| Description | 새 게시물 생성                |
| Parameters  | { body: '...', media: '...' } |

HTTP API의 파라미터는 생성되는 게시물의 유형에 따라 달라진다. <br />
대부분의 경우에는 인터뷰에서 핵심 논의 사항이 아니다. <br />
응답 형식은 단일 게시물이나 피드의 최신 게시물 목록일 수 있다. <br />
단일 게시물이 반환되는 경우, API 응답은 피드 API 내의 피드 게시물 항목과 유사하다.

```javascript
{
  "id": "124",
  "author": {
    "id": "456",
    "name": "John Doe"
  },
  "content": "Hello world",
  "image": {
    "src": "https://www.example.com/feed-images.jpg",
    "alt": "An image alt", // 사용자 제공 또는 서버에서 생성
    // 크기 등 다른 유용한 속성들도 포함될 수 있음
  },
  "reactions": {
    "likes": 20,
    "haha": 15
  },
  "created_time": 1620639583
}
```

이런 새 게시물 데이터가 주어지면, 클라이언트 스토어는 이를 피드 목록의 시작 부분에 추가해야 한다. <br />
이런 방식으로 실시간 업데이트가 많은 뉴스 피드에서 `커서 기반 페이지네이션`을 사용하면, 데이터 일관성과 사용자 경험을 모두 개선할 수 있다.

---

## 최적화 방법과 더 깊이 들어가기

### 일반 최적화

이 최적화 방법은 페이지의 모든 섹션에 적합하다.

### 코드 나누기

앱이 커지면서 페이지와 기능의 수가 늘어난다. <br />
그렇게 앱을 실행하는데 필요한 JavaScript와 CSS 코드도 같이 늘어난다. <br />
코드 나누기는 각 분리된 파일에 페이지가 필요한 코드만 갖게 나누는 기술이다. <br />
그래서 병렬적으로 불러오거나, 필요할 때만 불러오도록 할 수 있다.

보통, 코드 나누는 건 두 단계로 진행된다.

1. 페이지별로 나누기 <br />
   각 페이지는 각자 필요한 JavaScript와 CSS만을 불러온다.

2. Lazy 로딩 <br />
   덜 중요한 자원은 초기 렌더링 이후나 필요할 때만 부르면 된다. <br />
   가령 페이지를 내렸을 때만 필요한 코드라든지, 모달같이 액션이 있을 때만 사용되는 코드라든지 말이다.

뉴스 피드 앱은 싱글 페이지라서 페이지 단위로 코드를 나누는 것과 관련이 없다. <br />
하지만 Lazy 로딩은 여러 방면에서 굉장히 유용하다. <br />
Lazy 로딩은 피드 포스트에 대한 이야기를 할 때 더 다룬다. <br />
그만큼 피드 포스트 UI와 관련이 크다.

페이스북은 JavaScript 로딩을 3개의 티어로 나눴다.

1. Tier 1 <br />
   최초 화면을 그리기 위한 기본 레이아웃을 불러온다. <br />
   초기 로딩 상태를 위한 UI 스켈레톤을 포함한다. <br />
   화면 상단(above-the-fold) 콘텐츠의 기본 구조를 보여준다.

2. Tier 2 <br />
   화면 상단의 모든 콘텐츠를 완전히 렌더링하는데 필요한 JavaScript를 불러온다. <br />
   이 단계가 완료되면, 코드 로딩으로 인한 화면의 시각적 변화가 더이상 없어야 한다.

3. Tier 3 <br />
   화면 표시 후에만 필요한 리소스들을 불러온다. <br />
   이 리소스는 현재 화면에 보이는 픽셀에 영향을 주지 않는 요소들이다. <br />
   로깅 코드나 실시간 데이터 업데이트를 위한 구독(subscription) 등이 포함된다.

[원본 사이트](https://engineering.fb.com/2020/05/08/web/facebook-redesign/)

**에러 상태** <br />
네트워크 요청이 실패된 상황에서 보여주거나, 연결이 되지 않았을 때 보여준다.

### 피드 목록 최적화

피드 목록은 각 피드 포스트를 포함한 컨테이너 요소를 의미한다.

### 인피니트 스크롤

인피니트 스크롤은 현재 로딩된 피드를 끝까지 다 봤을 때, 다음 포스트를 불러오는 역할을 한다. <br />
이때 사용자는 다음 포스트를 불러오기 위해 기다리는 동안 로딩중 표시를 보게 된다.

대기 시간을 줄이거나, 아예 없애는 방법이 있다. <br />
유저가 해당 페이지 바닥에 도달하기 전에 다음 포스트를 불러오는 방식이다.

트리거 거리는 대체로 뷰포트 높이 정도면 충분하다. <br />
이상적인 거리는 불필요한 로딩과 대역폭 낭비를 피할만큼 짧으면서도,<br />
사용자가 페이지 하단까지 스크롤하기 전에 나머지 콘텐츠를 로드할 수 있을 만큼 넓어야 한다. <br />
네트워크 연결 속도와 사용자의 스크롤 속도를 기반으로 동적인 거리를 계산할 수 있다.

무한 스크롤을 구현하는 데는 두 가지 유명한 방법이 있다. <br />
둘 다 피드 하단에 마커 요소를 렌더링하는 걸 포함한다.

1. 스크롤 이벤트 감지 <br />
   페이지에 스크롤 이벤트 리스너(throttle 처리)를 추가하거나,<br />
   타이머를 통해 마커 요소의 위치가 페이지 하단으로부터 특정 임계값 내에 있는지 확인한다. <br />
   마커 요소의 위치는 `Element.getBoundingClientRect`를 사용해 얻을 수 있다.

2. Intersection Observer API <br />
   마커 요소가 다른 요소에 진입하거나, 나가는 걸 모니터링하거나 지정된 양만큼 교차하는 걸 감지하기 위함으로 사용한다.

`Intersection Observer API`는 브라우저 네이티브 API다. <br />
그래서 `Element.getBoundingClientRect`보다 선호된다.

> Intersection Observer API를 사용하면, <br />
> 코드에서 모니터링하고자 하는 요소가 다른 요소(뷰포트)에 진입하거나 나갈 때,<br />
> 또는 두 요소가 교차하는 정도가 요청된 양만큼 변경될 때 실행되는 콜백 함수를 등록할 수 있다. <br />
> 이를 통해 웹사이트는 이러한 요소 교차를 감시하기 위해 메인 스레드에서 별도의 작업을 할 필요가 없으며, <br />
> 브라우저는 필요에 따라 교차 관리를 최적화할 수 있다.

[InterSection Observer API / MDN](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)

### 가상화 리스트 (Virtualized List)

무한 스크롤에서는 로드된 모든 피드 항목들이 하나의 페이지에 있다. <br />
사용자가 페이지를 아래로 스크롤할수록 더 많은 게시물이 `DOM`에 추가되는데, <br />
피드 게시물은 복잡한 `DOM`구조 (렌더링할 세부 정보가 많음)을 갖고 있어 `DOM`크기가 빠르게 증가한다. <br />
소셜 미디어 웹사이트는 수명이 긴 앱 (특히 단일 페이지 앱의 경우)이며, <br />
피드 항목 리스트가 쉽게 길어질 수 있다. <br />
그래서 피드 항목의 수가 DOM 크기, 렌더링, 브라우저 메모리 사용 측면에서 성능 문제의 원인이 될 수 있다.

가상화된 리스트는 뷰포트 내에 있는 게시물만 렌더링하는 기술이다. <br />
실제로 페이스북은 화면 밖의 피드 게시물 내용을 빈 `<div>`로 대체한다. <br />
스크롤 위치를 유지하기 위해 동적으로 계산된 인라인 스타일 (`style="height: 300px"`)을 추가하고 `hidden` 속성을 부여한다. <br />
이는 다음과 같은 측면에서 렌더링 성능을 향상시킨다.

1. 브라우저 페인팅 <br />
   렌더링할 DOM 노드가 적어지고, 레이아웃 계산이 줄어든다.

2. 가상 DOM 조정 <br />
   게시물이 더 단순한 빈 버전이 되므로, React가 가상 DOM과 실제 DOM을 비교해 필요한 DOM 업데이트를 결정하기가 더 쉬워진다. <br />
   페이스북과 트위터 웹사이트 모두 이를 사용한다.

### 로딩 인디케이터

매우 빠르게 스크롤하는 사용자들의 경우,<br />
브라우저가 사용자가 페이지 하단에 도달하기 전에 다음 게시물 세트에 대한 요청을 시작하더라도, 요청이 아직 반환되지 않았을 수 있다. <br />
이때 요청 상태를 반영하는 로딩 인디케이터가 표시되어야 한다.

스피너를 보여주는 대신, 게시물 내용과 비슷한 모양의 시머 로딩 효과를 사용하는 것이 더 나은 경험이 될 수 있다. <br />
이는 시각적으로 더 보기 좋고, 새로운 게시물이 로드된 후의 레이아웃 변동(thrash)를 줄이는 데도 사용될 수 있다. <br />
스켈레톤 디자인을 의미한다.

### 동적 로딩 카운트

앞서 "Interface" 섹션에서 언급했듯이, 커서 기반 페이지네이션이 뉴스 피드에 더 적합하다. <br />
커서 기반 페이지네이션의 장점은 클라이언트가 후속 호출에서 가져올 항목 수를 변경할 수 있다는 것이다. <br />
이를 활용해 브라우저 창 높이에 따라 로드할 게시물 수를 커스터마이징할 수 있다.

초기 로드 시에는 창 높이를 알 수 없으므로 필요한 게시물 수를 보수적으로 과다 요청해야 한다. <br />
하지만 후속 요청에서는 브라우저 창 높이를 알고 있으므로, 그에 따라 가져올 게시물 수를 조정할 수 있다.

### 피드 스크롤 위치 유지

사용자가 다른 페이지로 이동했다가, 피드로 돌아올 때 피드 스크롤 위치가 유지되어야 한다. <br />
단일 페이지 앱에서는 피드 리스트 데이터를 스크롤 위치와 함께 클라이언트 스토어에 캐싱하여 구현이 가능하다. <br />
사용자가 피드 페이지로 돌아올 때, 데이터가 이미 클라이언트에 있기에 클라이언트 스토어에서 피드 리스를 읽어, 이전 스크롤 위치와 함께 즉시 화면에 표시할 수 있다. <br />
그래서 서버와의 통신이 필요하지 않다.

### 오래된 피드

사용자들이 뉴스 피드 앱을 브라우저 탭으로 열어둔 채 전혀 새로고침하지 않는 것은 흔하다. <br />
마지막으로 가져온 시간이 몇 시간 전이라면, 새로운 게시물이 있을 수 있고, 로드된 피드가 오래된 것으로 간주된다. <br />
이때 사용자에게 새로고침이나 피드 재요청을 프롬프트하는 것이 좋다. <br />
새 피드를 다시 가져올 때는 메모리 공간을 확보하기 위해, 현재 피드를 메모리에서 완전히 제거할 수 있다.

다른 방법으로는 새로운 피드 게시물을 피드 상단에 자동으로 추가하는 것이지만, <br />
이는 원하지 않을 수 있으며, 스크롤 위치에 영향을 주지 않도록 추가적인 주의가 필요하다.

현재 페이스북은 탭이 일정 시간 동안 열려있으면, 피드를 강제로 새로고침하고 상단으로 스크롤한다.

### 피드 게시물 최적화

피드 게시물은 작성자, 타임스탬프, 내용, 좋아요/댓글 버튼 등의 세부 정보를 포함하는 개별 게시물 요소다.

### 필요할 때만 데이터 기반 종속성 제공

뉴스 피드 게시물은 다양한 형식으로 제공될 수 있다. <br />
각 게시물은 커스텀 렌더링 코드가 필요하다. <br />
실제로 페이스북 피드는 50가지 이상의 다른 게시물 형식을 지원한다.

클라이언트에서 모든 게시물 형식을 지원하는 한 가지 방법은 모든 가능한 형식의 컴포넌트 JavaScript 코드를 미리 로드하는 것이다. <br />
하지만 모든 사용자의 피드가 모든 게시물 형식을 포함하지는 않을 것이며, 사용되지 않는 JavaScript가 많을 것이다. <br />
다양한 피드 게시물 형식으로 인해, 모든 형식의 JavaScript 코드를 미리 로드하면 성능 문제가 발생할 수 있다.

받은 데이터에 따라 컴포넌트를 지연 로드할 수 있다면 좋겠지만, <br />
이는 이미 가능하지만 데이터를 가져오고 렌더링할 게시물 유형을 알게 된 후에 컴포넌트를 지연 로드하기 위해 추가적인 네트워크 왕복이 필요하다.

### Relay와 데이터 기반 의존성

페이스북은 JavaScript 기반 `GraphQL` 클라이언트인 `Relay`를 사용해 서버에서 데이터를 가져온다. <br />
`Relay`는 React 컴포넌트와 `GraphQL`을 결합해 React 컴포넌트가 필요한 데이터 필드를 정확히 선언할 수 있게 한다. <br />
`Relay`가 `GraphQL` 지시어를 통한 데이터 기반 의존성이라는 기능을 갖고 있다. <br />
그래서 데이터 유형과 함께 컴포넌트 코드를 가져온다. <br />
이는 추가적인 네트워크 왕복없이 위에서 언급한 과도한 컴포넌트 문제를 효과적으로 해결한다. <br />
특정 게시물 형식이 표시될 때만 관련 코드를 로드한다.

```javascript
... on Post {
  ... on TextPost {
    @module('TextComponent.js')
    contents
  }
  ... on ImagePost {
    @module('ImageComponent.js')
    image_data {
      alt
      dimensions
    }
  }
}
```

이 GraphQL 쿼리는 백엔드에게 다음을 지시한다.

- 텍스트 기반 게시물인 경우, 텍스트 내용과 함께 `TextComponent JavaScript` 코드 반환 <br />
- 이미지가 첨부된 게시물인 경우, 이미지 데이터와 함께 `ImageComponent JavaScript` 코드 반환

이를 통해 클라이언트가 모든 가능한 게시물 형식의 컴포넌트 코드를 미리 로드할 필요가 없어진다. <br />
그래서 페이지에 필요한 초기 코드 양을 줄일 수 있다.

### 멘션/해시태그 렌더링

피드 게시물 내의 텍스트 내용이 단순 텍스트 이상일 수 있다는 걸 알 수 있다. <br />
소셜 미디어 앱에서는 멘션과 해시태그를 흔히 볼 수 있다. <br />
태그와 멘션에 대한 메타데이터를 포함할 수 있도록 게시물 메시지를 특별한 형식으로 저장해야 한다.

### 메세지 저장 형식 옵션

1. HTML 형식 <br />
   가장 단순한 형식은 `HTML`로, 표시하고 싶은 방식 그대로 메시지를 저장한다. <br />

```html
<a href="...">#AboutLastNight</a> is here... and ready to change the meaning of
date night... Absolute comedy 🤣 Dropping 2/10 on <a href="...">HBO Max</a>!
```

`HTML`로 저장하는 건 일반적으로 좋지 않다.

- 크로스 사이트 스크립팅(XSS) 취약점을 일으킬 수 있다. <br />
- 메시지의 메타데이터와 표시를 분리하는 것이 더 낫다. <br />
- 향후 멘션/해시태그를 렌더링하기 전에 꾸미거나 링크에 클래스명을 추가하고 싶을 수 있다. <br />
- HTML 형식은 앱 클라이언트(iOS/Android 등)에서 API 재사용성이 떨어진다.

2. 커스텀 구문 <br />
   해시태그와 멘션에 대한 메타데이터를 캡쳐하기 위해 커스텀 구문을 사용할 수 있다.

- 해시태그 : 특별한 구문이 필요없으며, "#"으로 시작하는 단어를 해시태그로 간주할 수 있다. <br />
- 멘션 구문 : `[[#1234: HBO MAX]]`와 같은 구문으로 엔티티 ID와 표시할 텍스트를 캡처할 수 있다. <br />
  페이스북과 같은 사이트에서는 사용자가 멘션 내의 텍스트를 커스터마이징할 수 있기 때문에 엔티티 ID만 저장하는 것으로는 충분하지 않다.

메시지를 렌더링하기 전에 정규식을 사용해 해시태그와 멘션을 파싱하고, 커스텀 스타일이 적용된 링크로 대체할 수 있다. <br />
커스텀 구문은 향후 새로운 종류의 리치 텍스트 엔티틸를 지원할 계획이 없다면, 충분히 견고한 경량 솔루션이다.

### 리치 텍스트 에디터 형식

`Draft.js`는 Meta가 만든 인기있는 리치 텍스트 에디터다. <br />
`Draft.js`를 통해 사용자는 해시태그와 멘션같은 자신만의 리치 텍스트 엔티티를 만들 수 있다. <br />
2022년에 Meta는 `Draft.js`의 후속작인 `Lexical`을 출시했다. <br />
페이스북에서 리치 텍스트 편집과 표시에 `Lexical`을 사용하고 있다.

인기 있는 리치 텍스트 형식을 사용하면, 커스텀 파싱 코드를 작성할 필요가 없다. <br />
그리고 향후 더 많은 유형의 리치 텍스트 엔티티로 쉽게 확장할 수 있는 장점이 있다. <br />
하지만 이런 형식은 커스텀 구문 버전보다 문자열이 길어 네트워크 페이로드 크기가 커지고 저장 공간도 더 많이 필요하다.

### 이미지 렌더링 최적화

1. CDN (Content Delivery Network) <br />
   더 빠른 로딩 성능을 위해 CDN을 사용해 이미지를 호스팅하고 제공한다.

2. 최신 이미지 형식 <br />
   `WebP`와 같은 우수한 무손실/손실 압축을 제공하는 최신 이미지 형식을 사용한다.

3. 이미지 대체 텍스트 <br />
   `<img>`태그에 적절한 alt 텍스트 사용 <br />
   페이스북은 머신러닝과 컴퓨터 비전을 사용해 사용자가 업로드한 이미지를 처리하고 설명을 만든다. <br />
   최근에는 생성형 AI 모델도 이러한 작업에 매우 효과적이다.

4. 디바이스 화면 속성 기반 이미지 로딩 <br />
   피드 리스트 요청 시, 브라우저 크기를 전송해 서버가 반환할 이미지 크기를 결정한다. <br />
   이미지 처리(리사이징) 기능이 있는 경우, `srcset`을 사용해 현재 뷰포트에 가장 적합한 이미지 파일을 로드한다.

5. 네트워크 속도 기반 적응형 이미지 로딩 <br />
   좋은 인터넷 연결과 WiFi 사용 기기 : 아직 뷰포트에 없지만, 곧 진입할 이미지 미리 가져오기 <br />
   느린 인터넷 연결 : 저해상도 플레이스홀더 이미지를 렌더링하고, 사용자가 명시적으로 클릭해야 고해상도 이미지를 로드한다.

### 초기 렌더링에 불필요한 코드의 지연 로딩

초기 렌더링에 필요하지 않은 피드 게시물과의 상호작용

- 리액션 팝오버 <br />
- 우측 상단 줄임표 아이콘 버튼으로 표시되는 드롭다운 메뉴 (일반적으로 추가 작업을 숨기는 용도)

이러한 컴포넌트 코드는 다음과 같은 경우에 다운로드할 수 있다.

- 브라우저가 유휴 상태일 때, 낮은 우선순위 작업으로 <br />
- 사용자가 버튼 위에 마우스를 올리거나 클릭할 때 필요에 따라

이는 페이스북의 계층 정의에 따르면 `Tier 3`이 된다.

### 낙관적 업데이트

낙관적 업데이트는 서버에 요청을 보내는 사용자 상호작용 후, 클라이언트가 즉시 업데이트된 상태를 반영한다. <br />
대부분의 요청에서 그래야 하는 것처럼 서버 요청이 성공할 것이라고 낙관적으로 가정하는 성능 기법이다. <br />
이는 사용자에게 즉각적인 피드백을 제공하고, 체검 성능을 향상시킨다. <br />
서버 요청이 실패하면 UI 변경을 되돌리고, 오류 메시지를 표시할 수 있다.

뉴스 피드에서는 리액션 상호작용에 대해 사용자의 리액션과 업데이트된 총 리액션 수를 즉시 표시하는 방식으로 낙관적 업데이트를 적용할 수 있다.

낙관적 업데이트는 `Relay`, `SWR`, `React-Query`와 같은 현대적인 쿼리 라이브러리에 내장된 강력한 기능이다.

### 타임스탬프 렌더링

이는 다국어 타임스탬프와 오래된 상대적 타임스탬프와 같은 몇 가지 문제로 인해 논의할 가치가 있다.

### 다국어 타임스탬프

페이스북과 트위터같은 글로벌 인기 사이트는 다양한 언어에 대해 UI가 잘 작동하도록 해야 한다. <br />
다국어 타임스탬프를 지원하는 방법에는 몇 가지가 있다.

1. 서버가 원시 타임스탬프 반환 <br />
   서버가 원시 타임스탬프를 반환하고, 클라이언트가 사용자의 언어로 렌더링한다. <br />
   유연하지만, 클라이언트가 다양한 언어의 문법 규칙과 번역 문자열을 포함해야 한다. <br />
   지원하는 언어 수에 따라 JavaScript 크기가 상당히 커질 수 있다.

2. 서버가 번역된 타임스탬프 반환 <br />
   서버에서 처리가 필요하지만, 다양한 언어의 타임스탬프 형식 규칙을 클라이언트에 전송할 필요없다. <br />
   번역기 서버에서 이뤄지므로 클라이언트에서 타임스탬프를 조작할 수 없다.

3. Intl API <br />
   최신 브라우저는 `Intl.DateTimeFormat()`와 `Intl.RelativeTimeFormat()`을 사용해 원시 타임스탬프를 원하는 형식의 번역된 날짜 및 시간 문자열로 변환할 수 있다.

### 상대적 타임스탬프의 오래됨 문제

상대적 형식 (3분 전, 1시간 전 등)으로 타임스탬프를 표시할 경우, <br />
특히 사용자가 페이지를 새로고침하지 않는 앱에서는 최근 타임스탬프가 쉽게 오래될 수 있다. <br />
최근 타임스탬프(1시간 미만)의 경우, 타이머를 사용해 지속적으로 업데이트하면 경과된 시간을 정확하게 반영할 수 있다.

### 아이콘 렌더링

게시물의 좋아요, 댓글, 공유 등 액션 버튼에는 아이콘이 필요하다. <br />
아이콘을 렌더링하는 방법에는 여러가지가 있다.

1. 개별 이미지 <br />
   장점 : 구현이 간단하다. <br />
   단점 : 이미지당 여러 다운로드 요청 필요

2. 스프라이트 시트 <br />
   장점 : 모든 아이콘 이미지를 한 번의 HTTP 요청으로 다운로드 <br />
   단점 : 설정이 복잡하다.

3. 아이콘 폰트 <br />
   장점 : 확장 가능하고, 선명하다. <br />
   단점 : 전체 폰트를 다운로드해야 함, 폰트 로딩 중 스타일이 적용되지 않은 콘텐츠가 깜빡임

4. SVG <br />
   장점 : 확장 가능하고, 선명하다. 캐시가 가능하다. <br />
   단점 : 파일 다운로드 중 깜빡임, 이미지당 다운로드 요청 필요

5. 인라인 SVG <br />
   장점 : 확장 가능하고 선명함 <br />
   단점 : 캐시 불가능

페이스북과 트위터는 `인라인 SVG`를 사용한다. 이게 최근 트렌드다. <br />
이 기술은 뉴스 피드에만 국한되지 않고, 거의 모든 웹 앱에 관련이 있다.

### 게시물 축약

매우 긴 메시지 내용을 가진 게시물은 축약하고, "더 보기" 버튼 뒤에 나머지를 숨긴다.

많은 활동 (많은 좋아요, 리액션 등)이 있는 게시물의 경우에, 원시 수치 대신 적절히 약어로 표시해 읽기 쉽고 규모를 충분히 전달한다.

- 좋음 : "John, Mary와 103K 명의 다른 사람들" <br />
- 나쁨 : "John, Mary와 103,312 명의 다른 사람들"

해당 요약 내용은 서버나 클라이언트에서 구성이 가능하다. <br />
서버 vs 클라이언트에서 수행하는 것의 장단점은 타임스탬프 렌더링과 유사하다. <br />
하지만 사용자 목록이 매우 큰 경우, 전체 목록을 전송하지 않아야 한다.

### 피드 댓글

일반적으로 댓글 렌더링과 댓글 작성에도 동일한 규칙이 적용된다.

1. 댓글 목록 가져오기를 위한 커서 기반 페이지네이션 <br />
2. 게시물 작성/편집과 유사한 방식으로 댓글 작성 및 편집 <br />
3. 댓글 입력에서 이모지/스티커 선택기 지연 로딩 <br />
4. 낙관적 업데이트 <br />
   새 댓글을 기존 댓글 목록에 추가해 즉시 반영 <br />
   새로운 리액션과 업데이트된 리액션 수를 즉시 표기

### 실시간 댓글 업데이트의 중요성

페이스북 피드 댓글의 실시간 업데이트는 새로운 댓글과 업데이트된 리액션 수를 실시간으로 보여준다. <br />
그래서 사용자 참여와 상호작용을 향상시킨다. <br />
이는 수동으로 새로고침할 필요없이 진행중인 대화에 적극적으로 참여하도록 장려하는 동적이고, 반응적인 커뮤니케이션 환경을 조성한다. <br />
실시간 업데이트의 즉시성은 사용자 유지율 증가에 기여한다.

### 구현 방법

1. 단기 폴링 (short polling) <br />
   클라이언트가 고정된 간격으로 서버에 반복적으로 업데이트 확인 요청을 보냄 <br />
   각 요청 후, 연결이 종료되고 서버는 현재 상태나 가능한 업데이트로 즉시 응답 <br />
   구현이 간단하지만, 다른 고급 기술에 비해 네트워크 트래픽과 서버 부하가 높을 수 있음

2. 장기 폴링 (long polling) <br />
   새 데이터가 사용 가능할 때까지 연결을 유지하는 방식으로 단기 폴링을 확장 <br />
   구현이 더 간단하지만, 다른 접근 방식에 비해 지연시간이 길어지고 서버 부하가 증가할 수 있음

3. 서버-전송 이벤트 (SSE) <br />
   서버가 단일 HTTP 연결을 통해 웹 클라이언트에 업데이트를 푸시할 수 있게 하는 표준 웹 기술 <br />
   서버에서 시작되는 업데이트에 특히 적합한 간단하고, 효율적인 매커니즘

4. 웹소켓 <br />
   단일 장기 연결을 통해 전이중 통신 채널 제공 <br />
   양방향 통신으로 서버와 클라이언트가 언제든 서로 메시지를 주고받을 수 있음 <br />
   낮은 지연시간과 높은 상호작용성이 필요한 앱에 적합

5. HTTP/2 서버 푸시 <br />
   HTTP/2에서는 클라이언트의 요청을 기다리지 않고, 서버가 업데이트를 푸시할 수 있음 <br />
   실시간 업데이트에 다른 방법만큼 널리 사용되진 않지만, 특정 상황에선 효율적일 수 있음

페이스북은 웹소켓을 사용한다.

### 최적화 고려 사항

1. 화면에서 벗어난 게시물의 업데이트 가져오기는 비효율적 <br />
   게시물의 가시성에 따라 클라이언트가 업데이트를 구독 및 구독 취소할 수 있음 <br />
   이는 서버 인프라의 부하를 줄임

2. 모든 게시물을 동일하게 처리하지 않음 <br />
   많은 팔로워를 가진 사용자의 게시물은 더 맣은 사람이 보고 업데이트될 가능성이 높음 <br />
   이러한 게시물은 자주 추가 및 업데이트 됨 <br />
   사용자가 모든 새 댓글을 읽기엔 업데이트 속도가 너무 빠름 <br />
   그래서 모든 새 게시물이나 리액션을 가져오는 건 현명하지 않음 <br />
   이런 게시물의 실시간 업데이트는 디바운스/쓰로틀링으로 처리 가능 <br />
   특정 임계값을 넘어서면, 업데이트된 댓글과 리액션 수만 가져오는 것으로 충분

---

## 피드 작성기 최적화

### 해시태그와 멘션을 위한 리치 텍스트

피드 작성기에서 게시물을 작성할 때, 해시태그와 멘션이 포함된 결과물처럼 보이는 편집 경험이 있으면 좋다. <br />
하지만 `<input>`과 `<textarea>`는 일반 텍스트 입력과 표시만 허용한다. <br />
`contenteditable` 속성을 사용하면, 요소를 편집 가능한 리치 텍스트 에디터로 만들 수 있다.

하지만 `contenteditable="true"`를 그대로 프로덕션에서 사용하기엔 여러 문제가 있다. <br />
대신 검증된 리치 텍스트 에디터 라이브러리를 사용하는 게 좋다.

Meta는 `Lexical` 같은 리치 텍스트 에디터를 만들어 게시물과 댓글 작성 및 표시에 사용한다. <br />
다른 인기 있는 오픈소스 대안으로는 `TipTap`과 `Slate`가 있다.

### 종속성 지연 로딩

뉴스 피드 게시물 렌더링과 마찬가지로, 사용자는 다양한 형식으로 게시물을 작성할 수 있으며 각 형식별로 특수한 렌더링 코드가 필요하다. <br />
지연 로딩을 사용해 원하는 형식과 선택적 기능에 대한 리소스를 필요할 때 로드할 수 있다.

필요할 때, 코드를 지연 로드할 수 있는 중요하지 않은 기능들이 있다.

- 이미지 업로더 <br />
- GIF 선택기 <br />
- 이모지 선택기 <br />
- 스티커 선택기 <br />
- 배경 이미지

### 접근성

뉴스 피드의 접근성 고려사항

1. 피드 리스트<br />
   피드 HTML 요소에 `role="feed"` 추가

2. 피드 게시물 <br />
   각 피드 게시물 HTML 요소에 `role="article"` 추가 <br />
   피드 작성자 이름이 포함된 HTML 태그에 id 속성이 있다면, `aria-labelledby="<id>"` 사용 <br />
   피드 게시물 내의 콘텐츠는 키보드로 포커스 가능해야 함(`tabindex="0"` 추가)하고 적절한 `aria-role` 필요

3. 피드 상호작용 <br />
   페이스북 웹사이트에서는 "좋아요" 버튼 위에 마우스를 올리면, 더 많은 리액션 옵션을 볼 수 있음 <br />
   키보드 사용자를 위해 페이스북은 포커스될 때만 나타나는 버튼을 표시하고, 이 버튼을 통해 리액션 메뉴를 열 수 있음 <br />
   아이콘만 있는 버튼은 동반되는 레이블이 없는 경우, `aria-labels`가 있어야 함
