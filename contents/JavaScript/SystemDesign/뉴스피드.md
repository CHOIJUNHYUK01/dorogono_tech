# 뉴스피드

뉴스 피드 앱을 만드는 건, 클래식하다. <br />
하지만 이걸 어떻게 디자인하는지 더 깊게 들어가 얘기를 하는 콘텐츠가 거의 없다시피 한다.

페이스북, 인스타그램, X, 레딧 등이 예시다.

---

## 요구사항

### 핵심 기능

1. 해당 유저와 친구가 만든 포스트를 포함해 보여준다. <br />
2. 포스트는 좋아요와 같은 리액션 기능이 있어야 한다. <br />
3. 포스트를 만들어 올릴 수 있어야 한다.

답글과 공유 기능은 후에 다룬다. 핵심 기능은 아니다.

### 어떤 포스트를 보여주는가

우선적으로 텍스트와 이미지 기반 포스트다.

### 어떤 페이지네이션 UX가 피드에 사용되나

인피니트 스크롤이 주로 쓰인다. <br />
유저가 그들의 마지막 피드에 도달했을 때, 새 포스트를 보여주는 방식이다.

### 모바일 기기에서도 사용될 것인가

우선 순위는 아니지만, 있으면 좋다.

---

## 아키텍쳐 / high-level 디자인

![architecture](https://www.greatfrontend.com/img/questions/news-feed-facebook/news-feed-architecture.png)

### 각 컴포넌트별 책임

- Server : <br />
  피드 포스트를 불러오고, 새 포스트를 올리는 HTTP API를 제공한다.

- Controller : <br />
  앱의 데이터 흐름을 제어하고, 서버에 데이터를 요청한다.

- Client Store: <br />
  앱 전반에 걸쳐 필요한 데이터를 저장한다. <br />
  뉴스 피드의 맥락에서, 여기에 저장된 대부분의 데이터는 피드 UI에 필요한 서버에서 발생한 데이터다.

- Feed UI: <br />
  피드 포스트 목록을 포함한다. <br />
  새 게시물을 작성하기 위한 UI도 포함한다.

  1. Feed Post <br />
     피드 게시물의 데이터를 표시한다. <br />
     게시물과 상호작용할 수 있는 버튼을 포함한다.

  2. Post Composer <br />
     WYSIWYG 에디터를 제공한다. <br />
     WYSIWYG는 "What You See Is What You Get"의 약자다. <br />
     즉, "보이는 대로 얻게 해주는 편집기"라고 보면 된다.

### 렌더링 접근 방식

어디서 콘텐츠를 로딩할지, 서버 아니면 클라이언트에서 할지 결정할 수 있다.

- SSR (Server-Side Rendering) <br />
  서버 측에서 HTML을 렌더링하는 전통적인 방법이 있다. <br />
  SEO에 최적이고, 정적인 콘텐츠를 제공하거나 상호작용이 적다면 최적이다. <br />
  블로그, 문서, 쇼핑몰 페이지같은 게 여기에 속한다.

- CSR (Client-Side Rendering) <br />
  브라우저에서 렌더링한다. <br />
  JavaScript를 사용해, 동적으로 DOM 요소를 추가한다. <br />
  상호작용이 많은 콘텐츠에 최적이다. <br />
  대시보드 앱, 채팅 앱 등이 여기에 속한다.

뉴스 피드 앱은 이 둘 사이 어딘가에 속한다. <br />
정적인 콘텐츠도 많지만, 상호작용도 그에 맞게 많이 존재한다.

실제로, 페이스북은 하이브리드 접근을 한다. <br />
일단 SSR로 초기 로딩을 빠르게 한다. <br />
그 후에 상호작용을 할 수 있게 만든다. <br />
유저가 페이지 끝에 도달해서 새 뉴스 피드가 추가된다면, 그건 CSR을 사용하는 거다.

React와 Vue 같은 현대적인 UI JavaScript 프레임워크들과, Next.js와 Nuxt와 같은 메타 프레임워크들이 이러한 렌더링 전략을 지원한다.

[웹 랜더링 방식](https://web.dev/articles/rendering-on-the-web?hl=ko) <br />
[Meta가 채택한 방식](https://engineering.fb.com/2020/05/08/web/facebook-redesign/)

---

## 데이터 모델

뉴스 피드는 포스트 목록을 서버로부터 받아와 보여준다. <br />
앱의 거의 모든 데이터는 서버에서 만들어진 데이터이기 때문이다. <br />
유일한 클라이언트 측의 데이터는 "게시물 작성기"에 사용되는 형식이다.

| 사용 주체 | 자원 위치          | 속하는 곳        | 사용 데이터                                                 |
| --------- | ------------------ | ---------------- | ----------------------------------------------------------- |
| Feed      | Server             | Feed UI          | posts, pagination metadata                                  |
| Post      | Server             | Feed Post        | id, created_time, content, author 등 포스트에 포함된 데이터 |
| User      | Server             | Client Store     | id, name, profile_photo_url 등 개인정보                     |
| NewPost   | User input(Client) | Post Composer UI | message, image 등 게시물 작성에 필요한 데이터               |

### Advanced: Normalized store

페이스북과 트위터는 정규화된 client side store를 사용한다. <br />
"정규화"라는 단어가 새로울 수 있다. <br />
그렇다면, [Redux 문서](https://redux.js.org/usage/structuring-reducers/normalizing-state-shape)를 읽길 바란다. <br />
간단히 말해서, 정규화된 데이터 스토어의 특징은 다음과 같다.

- 데이터베이스와 유사한 구조를 갖는다. <br />
  각 데이터 타입이 자신만의 "테이블"에 저장된다. <br />
  마치 실제 데이터베이스처럼 말이다.

- 각 아이템은 고유한 ID를 가진다.

- ID를 통해(외부키와 같이) 중첩된 객체 대신, 다른 데이터 타입을 참조한다.

페이스북은 `Relay`(GraphQL 라이브러리)를 사용한다. <br />
트위터는 `Redux`를 사용한다. [트위터의 리덕스 사용기](https://medium.com/statuscode/dissecting-twitters-redux-store-d7280b62c6b1)

### 정규화된 스토어의 이점

1. 중복 데이터 감소 <br />
   UI의 여러 곳에서 표시될 수 있는 동일한 데이터에 대해 단일성을 가진다. <br />
   예를 들어, 여러 게시물이 같은 작성자에 의해 작성된 경우를 생각해보자. <br />

   ```javascript
   <!-- 정규화 이전 -->
   let posts = [
     { id: 1, author: { id: 1, name: "Kim", avatar: "url1" } },
     { id: 2, author: { id: 1, name: "Kim", avatar: "url1" } },
     { id: 3, author: { id: 1, name: "Kim", avatar: "url1" } },
   ];

    <!-- 정규화 이후 -->
   let authors = {
       1: { id: 1, name: "Kim", avatar: "url1" },
     },
     posts: {
       1: { id: 1, authorId: 1 },
       2: { id: 2, authorId: 1 },
       3: { id: 3, authorId: 1 },
     };
   ```

   이렇게 정규화를 하면서, 작성자 정보가 한 번만 저장되게 한다. <br />
   데이터 업데이트도 용이해지고, 메모리 사용이 효율적이게 된다. <br />
   데이터 일관성 유지가 쉬워진다.
