# React에서 벗어나야 할 경우

다른 DOM API를 사용해야 할 때 사용한다. <br />
단, DOM을 직접 수정하는 시도를 한다면, React가 만들어내는 변경 사항과 충돌을 발생시킬 위험을 감수해야 한다.

## Ref

- 렌더링 단계에서 React는 화면에 뭘 그려야 하는지 알아내도록 컴포넌트를 호출한다. <br />
- 커밋 단계에서 React는 변경 사항을 DOM에 적용한다.

렌더링 중에는 ref에 접근하는 걸 원하지 않는다. <br />
이는 DOM 노드를 보유하는 ref도 마찬가지다. <br />
첫 렌더링에는 DOM 노드가 아직 생성되지 않아서 `ref.current`는 `null`인 상태다. <br />
그리고 갱신에 의한 렌더링에서 DOM 노드는 아직 업데이트되지 않은 상태다. <br />
두 상황 모두 ref를 읽기에는 너무 이른 상황이다.

React는 `ref.current`를 커밋 단계에서 설정한다. <br />
DOM을 변경하기 전에 React는 관련된 `ref.current` 값을 미리 `null`로 설정한다. <br />
그리고 DOM을 변경한 후, React는 즉시 대응하는 DOM 노드로 다시 설정한다.

대부분 `ref` 접근은 이벤트 핸들러 안에서 일어난다. <br />
`ref`를 사용해 뭔가를 하고 싶지만, 그걸 시행할 특정 이벤트가 없을 때, `Effect`가 필요할 수도 있다.

### flushSync

이를 무시하고, 동기적으로 DOM을 변경하도록 지시할 수 있다.

```javascript
flushSync(() => {
  setText("");
  setTodos([...todos, newTodo]);
});
```

이와 같이, `useState`값을 이전 값이 아닌, 바로 변경하도록 한다.

### 주의사항

DOM 요소를 직접 삭제하고, `setState`를 사용해서 다시 DOM 노드를 노출시키면, 충돌이 발생한다. <br />
DOM을 직접 변경했을 떄, React는 DOM 노드를 올바르게 계속 관리할 방법을 모르기 때무니다.

**React가 관리하는 DOM 노드를 직접 바꾸지 말 것** <br />
단, 항상 이것이 불가능하다는 의미는 아니다. 주의 깊게 사용하라는 거다. <br />
안전하게 React가 업데이트할 이유가 없는 DOM 노드 일부는 수정할 수 있다. <br />
비어있는 요소를 지우거나, 추가하는 건 가능하다.

---

## Effect

렌더링 자체에 의해 발생하는 부수 효과를 특정한다. <br />
특정 이벤트가 아닌 렌더링에 의해 직접 발생한다. <br />
버튼 클릭 같은 것이 아닌, 서버 연결 설정과 같은 것이다. <br />
컴포넌트 표시를 주관하는 어떤 상호 작용과도 상관없이 발생해야 한다는 의미다. <br />
커밋이 끝난 후에 화면 업데이트 이후에 실행된다고 보면 된다. <br />
이 시점이 React 컴포넌트를 외부 시스템과 동기화하기 좋은 타이밍이다.

쉽게 말해, 렌더링의 결과로 실행된다. <br />
`state`를 설정하면 렌더링이 트리거 된다. <br />
만약, Effect 안에서 상태를 설정한다는 것은 기계의 전원 플러그를 기계 그 자체에 연결하는 것과 같다. <br />
Effect가 실행되면, `state`가 설정되어 렌더링되고, 다시 계속 반복하게 된다.

일반적으로 외부 시스템과 동기화하는 데 사용된다. <br />
외부 시스템이 없고, 다른 상태에 기반할 때는 필요하지 않다.

### 주의

컴포넌트에 무작정 추가하지 말 것! <br />
주로 React 코드를 벗어난 특정 외부 시스템과 동기화하기 위해 사용된다. <br />
이는 브라우저 API, 서드 파티 위젯, 네트워크 등을 포함한다. <br />
만약 당신의 Effect가 단순히 다른 상태에 기반해서 일부 상태를 조정하는 경우에는 필요하지 않다.

### 작성법

1. Effect 선언 : 모든 커밋 이후에 실행된다.

2. Effect 의존성 지정 : 대부분의 Effect는 모든 렌더링 후가 아닌, 필요할 때만 다시 실행되어야 한다. <br />
   예를 들어, 페이드 인 애니메이션은 컴포넌트가 나타날 때에만 트리거 되어야 한다. <br />
   채팅 방에 연결 및 해제하는 것은 컴포넌트가 나타나거나 사라질 때, 방이 변경될 때만 발생해야 한다. <br />
   의존성을 지정해서 이를 제어할 수 있다.

3. 필요한 경우, 클린업 함수 추가 : 일부 Effect는 수행 중이던 작업을 중지하거나 취소, 정리해야 할 수도 있다. <br />
   예를 들어, "연결"은 "연결 해제"가 필요하고, "구독"은 "구독 취소"가 필요하다. <br />
   "불러오기"는 취소 또는 무시가 필요하다. <br />
   이런 경우에 클린업 함수를 반환해서 어떻게 수행하는지 배우게 될 것이다.

### 애플리케이션 초기화

Effect가 아닐 때, 컴포넌트 외부에 배치하면, 브라우저가 페이지를 로드할 후에 한 번만 실행된다. <br />
이럴 경우, 상품 구매나 이런 걸 Effect에 넣지 말아야 한다. <br />
페이지가 마운트될 때마다 된다면 여러 번 실행될 가능성이 있다. <br />
즉, 사용자 이벤트 처리할 때는 불필요하다.

`props`, `state`로 계산할 수 있으면, 그것을 `state`나 `effect`에 넣지 말고, 렌더링 중에 계산하도록 해라. <br />
캐시가 필요하다면, `useMemo`를 사용할 수도 있다. <br />
이는 렌더링 중에 실행되고, 순수 계산에만 작동한다.

`props`를 기준으로 컴포넌트를 재렌더링하고 싶을 수도 있다. <br />
이때, `effect`보다는 `key`를 활용해 업데이트하자.
