# UI State 조건

시간에 따라 변화하는 데이터를 `state`라 한다. <br />
`state`는 모든 컴포넌트에 추가가 가능하고, 필요에 따라 업데이트가 가능하다. <br />
`state`는 컴포넌트별 메모리라고 보면 된다.

## 시간이 지나도 변하지 않나요?

그렇다면, 확실히 `state`가 아니다.

## 부모로부터 props를 통해 전달되나요?

확실히 `state`가 아니다.

## 컴포넌트 안의 다른 state, props를 갖고 계산이 가능한가요?

그렇다면 **절대로** `state`가 아니다.

---

## Props와 State 차이

둘 모두 데이터 "모델"이다. <br />

### Props

- 함수를 통해 전달되는 인자와 같은 성격을 가진다. <br />
- 부모 컴포넌트로부터 자식 컴포너늩로 데이터를 넘겨서 외관을 커스터마이징하게 해준다. <br />
- 예를 들어, `Form`은 color라는 props을 `Button`으로 보내, 내가 원하는 형태로 바꿀 수 있다.

### State

- 컴포넌트의 메모리 같은 성격을 가진다. <br />
- 컴포넌트가 몇몇 정보를 계속 따라갈 수 있게 해주고, 변화하면서 상호작용을 만든다. <br />
- 예를 들어, `Button`은 `isHovered`라는 state를 따라가는 것처럼 말이다.

`props`와 `state`는 다르지만, 함께 동작한다. <br />
`state`는 보통 부모 컴포넌트에 저장된다. <br />
그래서 부모 컴포넌트는 `state`를 변경할 수 있다. <br />
그리고 부모 컴포넌트는 `state`를 자식 컴포넌트에 `props`로서 전달한다.

---

## State가 있어야 할 위치 정하기

1. 해당 `state`를 기반으로 렌더링하는 모든 컴포넌트를 찾아라. <br />
2. 그들의 가장 가까운 공통되는 부모 컴포넌트를 찾아라. <br />
3. `state`가 어디에 위치해야 할지 결정하라. <br />
   - 대개, 공통 부모에 그냥 두긴 한다. <br />
   - 혹은, 공통 부모 상위의 컴포넌트에 둬도 된다. <br />
   - `state`를 소유할 적절한 컴포넌트를 찾지 못했다면, `state`를 소유하는 컴포넌트를 하나 만들어서 상위 계층에 추가해야 한다.

---

## Props 전달하고, 적용

구조 분해 할당으로 적용해도 되지만, 가끔은 "spread" 문법을 사용하는 것이 합리적일 떄도 있다. <br />
다만, 제한적으로 사용해야 한다. <br />
모든 컴포넌트에 "spread" 문법을 사용한다면 문제가 있는 것이다.

### 특징

항상 고정되어 있는 값이 아니라, 모든 시점에 반영한다. <br />
다만, 컴퓨터 과학에서는 "불변성"을 띄고 있다고 한다. <br />
컴포넌트가 `props`를 변경해야 하는 경우에, 부모 컴포넌트에 다른 `props`, 즉 새로운 객체를 전달하도록 "요청"해야 한다. <br />
그러면 이전의 `props`는 버려지고, JS 엔진은 기존 `props`가 차지했던 메모리를 회수한다.

"props 변경"을 시도하지 말라. <br />
선택한 색을 변경하는 등 사용자 입력에 반응해야 하는 경우에는 `state`가 필요할 것이다.

---

## 이벤트 응답하기

React에서는 JSX에 "이벤트 핸들러"를 추가할 수 있다. <br />
이는 클릭, 마우스 호버, 폼 인풋 포커스 등 사용자 상호작용에 따라 유발되는 사용자 정의 함수다. <br />
적절한 JSX 태그에 `prop` 형태로 전달한다.

### 이벤트 핸들러

컴포넌트 내부에서 선언되기에, 해당 컴포넌트의 `prop`에 접근이 가능하다. <br />
만약 디자인 시스템을 적용한다면, 버튼과 같은 컴포넌트는 동작을 지정하지 않고, 스타일만 지정한다. <br />
이럴 경우에, 이벤트 핸들러를 전달하면 된다.

이벤트 핸들러에 적절한 HTML 태그를 사용하는 것이 좋다. <br />
UI가 마음에 들지 않는다면, CSS를 통해 목적을 이룰 수 있다.

내부에서 `useState`값을 부른다면, 해당 렌더링에 대한 `state` 스냅샷을 제공한다. <br />
리렌더링이 된다면, 해당 이벤트 핸들러는 살아남지 못한다. <br />
모든 코드가 실행될 때까지 `state` 업데이트를 미루는 특성이 있다. <br />
이를 `batching`이라 한다.

### 이벤트 전파

특정 JSX 태그 내에서만 실행되는 `onScroll`을 제외한 React 내의 모든 이벤트는 전파된다. <br />
이를 멈추고 싶다면, `e.stopPropagation()`를 호출하면 된다.

드물게 전파가 중단된 상황에서도 자식 컴포넌트의 모든 이벤트를 캡처해 확인해야 할 수도 있다. <br />
분석을 위해 전파 로직과는 상관없이 모든 클릭 이벤트를 기록하고 싶은 것이 그 예시다. <br />
그럴 경우, 이벤트명 마지막에 `Capture`를 추가하면 된다.

---

## 컴포넌트의 메모리

컴포넌트는 상호 작용의 결과로 화면의 내용을 변경해야 하는 경우가 많다. <br />
컴포넌트는 현재 화면에 보여지는 값을 "기억"해야 한다. <br />
React는 이런 종류의 컴포넌트별 메모리를 `state`라 한다.

1. 지역 변수는 렌더링 간에 유지되지 않는다. <br />
   React는 이 컴포넌트를 두 번째로 렌더링할 때, 지역 변수에 대한 변경 사항은 고려하지 않고, 처음부터 렌더링한다.

2. 지역 변수를 변경해도 렌더링을 일으키지 않는다. <br />
   React는 새 데이터로 컴포넌트를 다시 렌더링해야 한다는 것을 인식하지 못한다.

### 컴포넌트를 새 데이터로 업데이트하기 위한 조건

1. 렌더링 사이에 데이터를 유지한다. <br />
2. React가 새로운 데이터로 컴포넌트를 렌더링하도록 유발한다.

### useState 훅이 제공하는 것

1. 렌더링 간에 데이터를 유지하기 위한 변수 <br />
2. 변수를 업데이트하고, React가 컴포넌트를 다시 렌더링하도록 유발하는 `state setter 함수`
