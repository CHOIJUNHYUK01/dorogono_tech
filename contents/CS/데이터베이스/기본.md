# 데이터베이스의 기본

데이터베이스는 일정한 규칙 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음이다. <br />
이러한 데이터베이스를 관리하는 시스템을 `DBMS`이라고 한다. <br />
물론 이 `DBMS`에 정의된 쿼리언어를 통해 데이터에 `CRUD`가 가능하다. <br />
데이터베이스는 트랜잭션, 동시 공유, 사용자에 따른 데이터 접근 권한 부여, 데이터 암호화, 백업 및 복구 등이 가능하다는 특징이 있다.

## 엔터티

사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사이자, 데이터베이스에서 실제 세계의 객체나 개념을 모델링한 것이다. <br />
DB내에서 하나의 고유하게 식별될 수 있는 속성을 가진다.

### 약한 엔터티와 강한 엔터티

엔터티는 약한 엔터티와 강한 엔터티로 나뉜다. <br />
예를 들어, A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적이라면, <br />
A는 약한 엔터티, B는 강한 엔터티다. <br />
예를 들어, 학생은 강한 엔터티고, 강의 등록은 약한 엔터티라 할 수 있다. <br />
강의 등록이라는 것 자체가 `학생 - 강의` 두 가지의 엔터티에 의존적이기 때문이다.

- 약한 엔터티: <br />
  독립적으로 존재할 수 없고, 다른 강한 엔터티에 의존하는 엔터티다. <br />
  이들은 보통 자체적인 주요 키를 갖지 않고, 관련된 강한 엔터티의 키를 참조한다.

- 강한 엔터티: <br />
  자체적인 주요 키(Primary Key)를 갖고, 다른 엔터티에 의존하지 않는 독립적인 엔터티다.

## 릴레이션

데이터베이스에서 정보를 구분해 저장하는 기본 단위이자, 엔터티의 집합과 그 엔터티의 속성을 표현하는 구조다. <br />
엔터티가 데이터베이스에 올라가면, 릴레이션이 된다. <br />
릴레이션은 관계형 데이터베이스에서는 "테이블"이라고 하며, NoSQL에서는 "컬렉션"이라 한다.

MySQL 기준: 레코드 - 테이블 - 데이터베이스 <br />
MongoDB 기준: 도큐먼트 - 컬렉션 - 데이터베이스

레코드가 쌓여 테이블이 되고, 테이블이 쌓여 데이터베이스가 되는 계층적인 구조를 갖는다.

## 속성과 도메인

### 속성

릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보다. <br />
"자동차"라는 엔터티에는 "차 번호", "바퀴 수", "차 색깔"이 있다.

### 도메인

릴레이션에 포함된 각각의 속성이 가질 수 있는 값의 집합이다. <br />
"성별"이라는 속성에는 `{남, 여}`라는 집합의 값만 가질 수 있다.

---

엔터티가 데이터베이스에 들어갈 때, 엔터티의 속성은 데이터베이스의 테이블 필드로 들어간다. <br />
이때 필드의 이름, 타입으로 변환되어 들어가게 된다. <br />
보통 한글로 된 필드는 쓰지 않고, 영어로 변환해 필드를 사용한다.

## 필드와 레코드

그러한 필드를 가진 데이터들이 1행, 2행 같이 행단위로 쌓이게 된다. <br />
이를 행(row) 단위 데이터, 레코드, 튜플이라고 부른다.

## 타입

타입은 데이터베이스마다 지원되는 것이 다르다. <br />
MongoDB는 `string`, `number`라는 단순한 타입밖에 지원되지 않는다. <br />
MySQL은 숫자 타입만 봐도 `tinyint`, `smallint` 등 세분화해서 지원한다.

## 문자열 CHAR

`CHAR`는 테이블을 생성할 때, 선언한 길이로 고정되며, 길이는 0-255 사이의 값을 가진다. <br />
레코드를 저장할 때는 무조건 선언한 길이 값으로 "고정"해서 저장된다.

## 문자열 VARCHAR

가별 길이 문자열로, 길이는 0에서 65,535 사이의 값을 가진다. <br />
입력된 데이터에 따라 용량을 가변해서 저장한다. <br />
아스키 코드를 담는다고 한다면, `varchar(10000)`으로 선언해도, 데이터 길이가 10이라면 `데이터: 10 바이트 + 길이 기록용 1바이트`로 총 11바이트로 용량을 가변해서 저장하는 것이다. <br />
참고로 `VARCHAR`의 최대 길이가 255를 초과하는 경우, 데이터 길이는 2바이트를 사용해 저장한다.

즉, 유동적인 데이터는 `varchar`, 유동적이지 않고 고정적인 데이터는 `char`로 저장하면 좋다.

## CHAR와 VARCHAR의 데이터 저장 로직 차이

`CHAR`는 데이터가 작거나 크거나 상관없이 4바이트씩 저장한다. <br />
`VARCHAR`는 유동적으로 저장된다.

## VARCHAR 최대 길이로 설정할 때 주의할 점

1. MySQL 행의 최대 크기는 65,535 바이트다. <br />
2. MySQL이 사용하는 문자 인코딩 방식은 5.5.3 버전부터 UTF8을 지원하는 `utf8mb4`다. <br />
   이는 4바이트가 필요한 이모지와 3바이트가 필요한 한글을 모두 커버하는 인코딩 방식이다. <br />
3. 괄호 안에 들어가는 숫자는 바이트가 아니라 길이 제한이다.

### 이모지와 이모티콘 차이

이모티콘과 이모지는 다르다. <br />
이모티콘은 텍스트의 조합으로 형태를 나타낸 것이다. <br />
이모지는 이미지 자체가 하나의 문자로 취급되는 것이다.

## 문자열 TEXT

TEXT는 최대 65,535 길이의 텍스트 데이터를 저장할 수 있다.

### VARCHAR와 TEXT 차이

- VARCHAR <br />
  행 내부(메모리)에 데이터를 직접 저장한다. <br />
  `VARCHAR(100)`을 선언하면, 해당 칼럼을 위한 공간(400바이트)가 필요하다. [utf 기준] <br />
  65,535까지 `max size limit`을 걸 수 있다. (실제로는 65,533으로 선언 가능) <br />
  인덱스를 걸 수 있다.

- TEXT <br />
  행 외부(디스크)에 저장되고, 행 내부에는 포인터가 저장된다. <br />
  해당 필드타입은 `TEXT`라 설정하면, 해당 포인터를 위한 공간 8바이트가 필요하다. <br />
  `max size limit`을 걸지 못한다. 무조건 65,535 길이의 데이터를 저장할 수 있다. <br />
  인덱스를 걸 때, 크기 제한을 해야 걸 수 있다. <br />
  적정 크기의 접두사(prefix)를 인덱스로 만든다는 크기 제한을 걸어줘야 한다.

**정리** <br />

- VARCHAR: 중간 정도의 문자열이고, 메모리에서 읽기에 읽기 성능이 더 좋다. <br />
- TEXT: 매우 큰 문자열이고, 디스크에서 읽기에 읽기 성능이 좋지 않아, 검색과 수정이 빈번하지 않은 데이터를 저장할 때 쓰인다.

이외에도 문자열 타입은 `TINYTEXT(255)`, `MEDIUMTEXT(1600만)`, `LONGTEXT(40억)`이 있다.

MySQL에서 TEXT 타입의 칼럼에 대해서도 `LIKE` 함수를 사용해 데이터를 검색할 수 있다. <br />
이 연산자는 문자열이 특정 패턴과 일치하는지 여부를 검사할 때 사용된다. <br />
TEXT 타입 뿐만 아니라, VARCHAR, CHAR 등 다른 문자열 타입 데이터에도 사용할 수 있다.

## 이진데이터 BLOB

이진 데이터를 저장하는 데 사용되는 데이터 타입이다. <br />
주로 이미지, 오디오, 비디오 등을 저장하며, 다음과 같이 파일을 직접 데이터에 삽입해 사용한다.

```sql
INSERT INTO `kundol`
(`img`)
VALUES
(LOAD_FILE('C:/Users/kundol/Desktop/dev/a.png'))
```

그러나 보통은 이 타입을 쓰지 않고, 이미지 호스팅 서비스(S3)를 이용해 해당 서비스에 올리고, 해당 url을 varchar 타입으로 저장하는 게 일반적이다.

### 왜 blob을 많이 안 쓸까?

1. 성능 문제: <br />
   데이터 베이스에 큰 이진 파일(이미지 등)을 저장하면, 데이터베이스의 성능이 저하될 수 있다. <br />
   처리하고 관리하는 것도 오래 걸리고, 이때문에 만약 백업을 한다고 한다면, 데이터베이스 백업 및 복구 시간도 증가한다.

2. 보안 문제: <br />
   데이터베이스에 이미지를 저장하면, 이 이미지에 대한 접근을 제어하고 관리하는 게 더 복잡해진다. <br />
   이는 보안 정책을 적용하고 유지하기 어렵게 만들 수 있다.

---

ENUM과 SET 모두 문자열을 열거한 타입이다. <br />
지정된 문자열 이외의 값이 들어가면 에러가 발생한다.

## ENUM

이 타입은 열에 할당할 수 있는 값의 리스트를 정의한다. <br />
이 리스트 중 하나만 선택하는 단일 선택만이 가능하다. <br />
이 값은 내부적으로 숫자로 저장되지만, 사용자에게는 문자열로 표시된다. <br />
`ENUM('red', 'green', 'blue')`를 사용하면, 해당 열에는 `'red'`, `'green'`, `'blue'`만 저장할 수 있다. <br />
정의된 문자열 리스트 외의 값을 넣으려고 하면, SQL은 에러를 발생시킨다. <br />
내부적으로는 `red: 0, green: 1, blue: 2`로 매핑된다. <br />
이 역시 최대 65,535개의 요소를 넣을 수 있다.

## SET

ENUM과 비슷하지만, 하나의 열에 여러 값을 저장할 수 있다는 점이 다르다. <br />
비트 단위 연산을 할 수 이씅며, 한 번에 여러 개의 조합으로 선택이 가능하다. <br />
64개의 요소를 넣을 수 있다.

ENUM과 SET의 경우, 공간적으로 이점이 있다. <br />
하지만, 애플리케이션 수정에 따라 데이터베이스에 정의된 리스트를 매번 수정해야 한다는 단점이 있다.

---

## 관계와 키

### 관계

- 1 : 1 <br />
- 1 : N <br />
- N : M <br />

### 키

데이터베이스를 설계할 때, 키(key)를 기반으로 테이블 간의 관계를 정의하는 데 사용한다. <br />
기본키, 외래키, 대체키, 후보키, 슈퍼키, 복합키가 있다.

슈퍼키는 유일성이 있고, 그 안에 포함된 후보키는 최소성까지 갖춘 키다. <br />
후보키 중에서 기본키로 선택되지 못한 키는 대체키가 된다. <br />
유일성은 중복된 값은 없다는 것이다.<br />
최소성은 필드를 조합하지 않고 최소 필드만 써서 키를 형성할 수 있는 것이다.

1. 기본키 (PK, Primary Key) <br />
   유일성과 최소성을 만족하는 키이자, 테이블의 각 행을 고유하게 식별하는 필드다. <br />
   이때 필드의 조합일 수도 있다. <br />
   각 테이블에는 하나의 기본키만 있을 수 있고, 보통 'ID', '번호' 필드가 기본키로 사용된다.

**자연키와 인조키** <br />
기본키는 보통 자연키와 인조키 둘 중에 골라서 설정한다. <br />
보통은 인조키로 설정한다.

- 자연키: <br />
  이미 데이터에 존재하고, 실제로 의미가 있는 필드(또는 필드의 조합)을 사용해 테이블의 행을 고유하게 식별하는 키를 말한다. <br />
  자연스럽게 데이터 내에서 발견되는 유일한 값이자, 의미있는 정보를 담고 있다. <br />
  그러나 언젠가는 변하는 속성을 지녀, 나중에 문제를 발생시킬 수 있다.

  예시로는 주민등록번호와 차량번호가 있다.

- 인조키(Surrogate Key): <br />
  테이블 행을 식별하기 위해 특별히 생성된, 일반적으로 숫자로 이뤄진 고유하게 식별하는 키다. <br />
  테이블 내에서 자동으로 생성되며, 일반적으로 아무런 실질적인 의미를 갖지 않는다. <br />
  다음과 같이 일련의 증가하는 숫자를 기밥ㄴ으로 만드는 게 대표적이다.

```sql
CREATE TABLE socks (
id INT NOT NULL AUTO_INCREMENT,
```

2. 외래키 (Foreign Key) <br />
   다른 테이블의 기본키를 참조하는 필드다. <br />
   외래키는 참조하는 기본키의 값과 일치해야 하며, 중복될 수 있고, NULL 값을 가질 수도 있다.

3. 대체키 (Alternate Key) <br />
   기본키로 선택되지 않은 후보키다.

4. 후보키 (Candidate Key) <br />
   기본키가 될 수 있는 후보며, 유일성과 최소성을 만족한다.

5. 슈퍼키 <br />
   테이블 내의 행을 고유하게 식별할 수 있는 유일성을 갖춘 키다.

6. 복합키 (Composite Key) <br />
   두 개 이상의 필드를 조합해 만든 키다. <br />
   이 키는 각 필드 단독으로는 행을 고유하게 식별하지 못하지만, 조합할 경우 가능하다.

---

## 조인

조인은 두 개 이상의 테이블을 연결해 데이터를 탐색하는 방법이다. <br />
내부 조인과 외부 조인이 있다. <br />
MySQL은 `JOIN`, MongoDB는 `lookup`이라는 쿼리로 처리한다.

### 내부 조인

두 테이블에서 일치하는 데이터만 반환한다. (교집합) <br />
예를 들어, 테이블 A와 B가 있을 때, A와 B에 모두 존재하는 데이터만 결과로 나타낸다.

### 외부 조인

`왼쪽`, `오른쪽`, `전체` 세 가지 유형으로 나뉜다.

- 왼쪽 외부 조인

첫 번째(왼쪽) 테이블의 모든 레코드와 두 번째(오른쪽) 테이블의 일치하는 레코드를 반환한다. <br />
오른쪽 테이블에 일치하는 레코드가 없다면, 결과는 왼쪽 테이블의 레코드와 `NULL` 값으로 구성된다.

- 오른쪽 외부 조인

두 번째(오른쪽) 테이블의 모든 레코드와 첫 번째(왼쪽) 테이블의 일치하는 레코드를 반환한다. <br />
왼쪽 테이블에 일치하는 레코드가 없다면, 결과는 오른쪽 테이블의 레코드와 `NULL` 값으로 구성된다.

- 전체 외부 조인

두 테이블의 모든 레코드를 반환한다. <br />
한 테이블에만 존재하는 레코드는 다른 테이블에 해당하는 부분이 `NULL` 값으로 채워진다.

## 성능 차이

일반적으로 내부 조인은 외부 조인보다 빠르다. <br />
보통의 내부 조인의 결과 집합에는 양쪽 테이블에서 일치하는 행만 필요하기에 처리할 데이터가 상대적으로 작기에 그렇다. <br />
다만, 실제 성능은 쿼리, 데이터베이스 구조, 인덱스 구조 등에 따라 다를 수 있다.

### 교차 조인

두 개 이상의 테이블에서 가능한 모든 행의 조합을 생성하는 조인 방법이다. <br />
두 테이블 간에 어떤 조인 조건이 없을 때 사용된다. <br />
두 테이블의 모든 행 간에 카테시안 곱을 형성한다.

- 성능: <br />
  교차 조인의 결과는 매우 많은 데이터를 생성하기에 성능이 좋지 않다. <br />
  다만 POC를 하거나, 테스팅을 할 때 사용된다. <br />
  다만 성능 저하때문에 `limit`을 걸기도 한다.

### 자연 조인

두 테이블 간의 동일한 이름을 가진 모든 열을 기반으로 조인한다. <br />
이는 명시적으로 조인 조건을 지정할 필요업이, 두 테이블에서 이름이 같은 모든 열에 대해 내부 조인을 수행한다.

- 성능: <br />
  자연 조인은 일반적으로 교차 조인에 비해 훨씬 적은 수의 행을 결과로 반환한다. <br />
  따라서 자연 조인은 교차 조인에 비해 성능이 보통은 더 좋다. <br />
  자연 조인은 간단하게 뭉뚱그려 데이터를 통합할 때 쓴다.

---

## 내부 조인이 아닌, 욍쪽 외부 조인을 써야할 때가 있나?

일치하는 데이터가 없는 경우에도 결과를 보고 싶을 때 사용한다. <br />
예를 들어, 모든 회원의 목록을 가져오고 싶지만, 일부 회원은 팀에 할당되지 않았을 수 있다. <br />
여기서 팀 테이블을 기준으로 회원 테이블과 `왼쪽 외부 조인`을 수행하면, 팀에 할당되지 않은 직원들의 정보도 결과에 포함된다.
