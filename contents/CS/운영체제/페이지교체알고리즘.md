# 페이지 교체 알고리즘

## 오프라인 알고리즘 (LFD)

스와핑이 일어날 때, 페이지 교체 알고리즘에 의해 페이지가 교체된다. <br />
그리고 이 알고리즘은 최대한 스와핑을 적게 하는 것이 목표다.

오프라인 알고리즘 (Longest Forward Distance)은 페이지 교체 알고리즘 중 가장 좋은 알고리즘이라 한다. <br />
이는 더이상 참조되지 않거나, 가장 늦게 다시 참조되는 페이지와 지금 요청된 페이지를 바꾸는 알고리즘이다.

### 예시

페이지 참조 순서: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3 <br />
메모리 최대 페이지수: 3개

단계별 설명

1. 초기 요청: 1, 2, 3 <br />
   처음 세 페이지는 비어있는 프레임에 하나씩 적재된다. <br />
   각각 페이지 폴트가 발생한다. <br />
   현재 메모리 : 1, 2, 3

2. 다음 요청: 4 <br />
   현재 메모리에 있는 페이지는 1, 2, 3이다. <br />
   각 페이지의 다음 참조는 다음과 같다. <br />
   1은 5번째 요청에, 2는 6번째 요청에, 3은 10번째 요청에 다시 사용된다. <br />
   3번 페이지가 가장 늦게 사용되니, 교체한다.
   현재 메모리: 1, 2, 4

3. 다음 요청: 1<br />
   1페이지는 이미 메모리에 있다. <br />
   현재 메모리: 1, 2, 4

4. 다음 요청: 2<br />
   2페이지 역시 이미 존재한다. <br />
   현재 메모리: 1, 2, 4

5. 다음 요청: 5 <br />
   현재 메모리에 있는 페이지의 다음 참조는 다음과 같다. <br />
   1은 8번째 요청, 2는 9번째 요청, 4는 다시 사용되지 않는다. <br />
   4페이지는 다시 사용되지 않으니, 교체한다. <br />
   현재 메모리: 1, 2, 5

6. 다음 요청: 1, 2, 3 <br />
   1과 2는 이미 존재한다. <br />
   3 요청시에는 아무거나 교체가 가능하다.

이 알고리즘은 향후 요청을 모두 알고 있다는 가정하에 가장 효율적인 교체를 한다. <br />
이론적으로는 최적이지만, 실제 시스템에서는 미래의 요청을 알 수 없다. <br />
그래서 이 알고리즘을 직접 구현하는 건 불가능하다.

대신 `LRU(Latest Recently Used)`나 `LFU(Least Frequently Used)`같은 실현 가능한 대체 알고리즘이 사용된다. <br />
즉, 사용할 수 없는 알고리즘이지만 다른 알고리즘과의 성능 비교에 대한 상한선을 제공한다.

---

## FIFO

가장 먼저 온 페이지부터 교체하는 방법이다.

## LRU

최근에 사용되지 않은 페이지를 바꾸는 방법이다. <br />
즉, 참조가 오래된 페이지를 바꾼다. <br />
이를 위해서 각 페이지마다 최근 사용한 횟수를 타나내는 자료 구조를 따로 만들어야 할 수도 있다.

## NUR (Not Used Recently)

LRU에서 발전한 알고리즘이다. <br />
NUR 또는 NRU라고도 불린다.

일명 clock 알고리즘이라 한다. <br />
먼저 0과 1을 가진 비트를 둔다. <br />
1은 최근에 참조됐고, 0은 참조되지 않음을 의미한다. <br />
만약 한 바퀴 도는 동안 사용되지 않으면 0이 된다. <br />
시계 방향으로 돌면서 0을 찾고, 찾으면 해당 페이지를 교체하고 1로 바꾸는 알고리즘이다.

## LFU

가장 참조 횟수가 적은 페이지를 교체하는 알고리즘이다. <br />
예를 들어, 0, 1, 2, 0, 0, 1, 2, 3 이렇게 들어오고 3개의 페이지밖에 없다고 해보자.

1. 0, 1, 2 담는다. <br />
2. 0 : 참조 횟수 2 <br />
3. 0 : 참조 횟수 3 <br />
4. 1 : 참조 횟수 2 <br />
5. 2 : 참조 횟수 2 <br />
6. 3 : 가장 참조 횟수가 적은 1과 스와핑
