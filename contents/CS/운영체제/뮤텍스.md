# 뮤텍스, 세마포어, 모니터

경쟁 상태를 해결하는 대표적인 방법 3가지다. <br />
이들은 상호 배제, 한정 대기, 진행의 융통성 조건을 만족시키며, 경쟁 상태를 해결한다.

### 상호 배제

한 프로세스가 임계 영역에 들어갔을 때, 다른 프로세스는 들어갈 수 없다.

### 한정 대기

특정 프로세스가 임계 영역 진입을 요청한 후, 해당 요청이 승인되기 전까지 다른 프로세스가 임계 영역에 진입하는 횟수를 제한한다. <br />
이를 통해 특정 프로세스가 영원히 임계 영역에 들어가지 못하게 하는 걸 방지한다.

### 진행의 융통성

만약 어떠한 프로세스도 임계 영역을 사용하지 않는다면, 임계 영역 외부의 어떠한 프로세스도 들어갈 수 있다. <br />
이때 프로세스끼리 서로 방해하지 않는다.

**융통성이란** <br />
형편이나 경우에 따라서 일을 이리저리 막힘없이 잘 처리하는 재주나 능력을 말한다.

---

## 뮤텍스

공유 자원을 `lock()`을 통해 잠금 설정하고, 사용한 후에 `unlock()`을 통해 잠금 해제가 되는 객체 `lock`을 기반으로 경쟁 상태를 해결한다. <br />
잠금이 설정되면, 다른 프로세스나 스레드는 잠긴 코드 영역에 접근할 수 없다. <br />
해제는 그와 반대가 된다. <br />
한 번에 하나의 프로세스만 임계 영역에 있을 수 있다.

## 세마포어

일반화된 뮤텍스다. <br />
간단한 정수 S와 두 가지 함수, `wait()`, `signal()`로 공유 자원에 대한 접근을 처리한다. <br />
이를 통해 여러 프로세스가 동시에 임계 영역에 접근할 수 있다.

- S는 현재 쓸 수 있는 공유 자원의 수 <br />
- `wait()`은 S를 1씩 감소시킨다.<br />
  감소시키다가 S가 음수가 된다면, 공유 자원을 쓸 수 없기 때문에, 프로세스는 차단되고 대기열에 있는 프로세스를 집어넣는다. <br />
- `signal()`은 S를 1씩 증가시킨다. <br />
  공유 자원을 프로세스가 다 쓴 상태다. <br />
  이때 S가 0 이하라면, 대기열에 있던 프로세스가 동작한다. <br />
  예를 들어, s.value가 -5라면, 5개의 프로세스가 자원을 기다리며 대기 중인 것이다.

세마포어는 바이너리 세마포어와 카운팅 세마포어로 나뉜다.

### 바이너리 세마포어

0과 1의 두 가지 값만 가질 수 있는 세마포어다. <br />
구현의 유사성으로 인해, 뮤텍스는 바이너리 세마포어라고 할 수 있다. <br />
하지만 엄밀히 말하면, 뮤텍스는 잠금을 기반으로 상호 배제가 일어나는 "잠금 매커니즘"을 사용한다. <br />
세마포어는 신호를 기반으로 상호 배제가 일어나는 "신호 매커니즘"을 사용한 차이점이 있다. <br />
여기서 "신호 매커니즘"은 휴대폰에서 노래를 듣다가, 친구로부터 전화가 오면 노래가 중지되고 통화 처리 작업에 관한 인터페이스가 등장하는 걸 상상하면 된다.

### 카운팅 세마포어

여러 개의 값을 가질 수 있는 세마포어다.

---

## 모니터

둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고, 해당 접근에 대해 인터페이스만 제공하는 객체다. <br />
이를 통해 공유 자원에 대한 작업을 순차적으로 처리한다.

### 세마포어와의 차이

모니터는 세마포어보다 구현하기 쉽다. <br />
한 번에 하나의 프로세스만 공유 자원에 접근할 수 있다. <br />
때문에 상호 배제가 자동이다. <br />
인터페이스를 기반으로 구축된다.

세마포어는 모니터보다 구현하기 어렵다. <br />
한 번에 여러 개의 프로세스가 공유 자원에 접근할 수 있다. <br />
때문에 상호 배제를 명시적으로 구현해야 한다. <br />
정수 변수를 기반으로 구축된다.

---

## 교착 상태

두 개 이상의 프로세스가 서로가 가진 자원을 기다리며 중단된 상태다. <br />
이 과정에서 각 프로세스는 서로가 원하는 자원을 유지한채, 다른 프로세스의 자원을 얻길 기다린다.

### 원인

교착 상태는 4가지 필요 조건으로 발생한다.

1. 상호 배제: <br />
   주어진 시간 내에 하나의 프로세스만 자원을 독점할 수 있다. <br />
   즉, 다른 프로세스는 접근이 불가능하다.

2. 점유 대기: <br />
   특정 프로세스가 점유한 자원을 다른 프로세스가 요청하며 대기하는 상태다.

3. 비선점: <br />
   다른 프로세스의 자원을 강제적으로 가져올 수 없다.

4. 환형 대기: <br />
   프로세스 A는 프로세스 B의 자원을 요구하고, B는 A의 자원을 요구하는 등 서로가 서로의 자원을 요구하는 상황이다.

이 4가지 조건을 충족해도, 교착 상태가 일어나지 않을 수도 있다. <br />
그러나, 4가지 조건을 "모두" 만족해야 일어난다.

### 해결 방법

1. 자원을 할당할 때, 애초에 조건이 성립되지 않도록 설계한다. <br />
2. 교착 상태 가능성이 없을 때만 자원이 할당되며, 프로세스당 요청할 자원의 최대치를 통해 자원 할당 가능 여부를 파악하는 **은행원 알고리즘**을 쓴다. <br />
3. 교착 상태가 발생하면, 사이클이 있는지 찾아보고, 이에 관련된 프로세스를 한 개씩 지운다. <br />
4. 교착 상태는 매우 드물게 일어나기에, 이를 처리하는 비용이 더 커서 교착 상태가 발생하면 사용자가 작업을 종료한다. <br />
   현대 운영 체제는 이 방법을 채택하고 있다. <br />
   예를 들어, 프로세스를 실행시키다 "응답 없음"이 뜨는 것이 교착 상태가 발생한 경우와 비슷하다.

### 은행원 알고리즘

교착 상태를 회피하는 알고리즘으로, 총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정 또는 불안정 상태로 나누고, 안정 상태로 가도록 자원을 할당하는 알고리즘이다.

**안정 상태** <br />
교착 상태를 일으키지 않은 상태다. <br />
프로세스의 최대 자원 요구량을 운영 체제가 충족시킬 수 있는 상태다.

**불안정 상태** <br />
안전 상태로 가는 순서열이 존재하지 않는 상태다.

- 은행원 알고리즘의 구조

`n * m 2차원 배열 3개`와 `n 1차원 배열 2개`를 사용한다.

1. available[i]: <br />
   운영 체제가 프로세스에게 자원을 줄 수 있는 양 <br />
   i 번째 사용 가능한 자원의 양

2. max[i][j]: <br />
   플세스 최대 요구량 <br />
   프로세스 i가 자원 j를 최대 요청할 수 있는 양

3. allocation[i][j]: <br />
   프로세스 자원할당량 <br />
   프로세스 i에 자원 j를 할당한 양

4. need[i][j]: <br />
   프로세스의 자원 추가 요구량 <br />
   프로세스 i가 자원 j를 추가 요청하는 양

5. finish[i]: <br />
   i번째 프로세스가 요청하는 양을 운영 체제가 만족할 수 있는지를 파악하는 불리언 배열

- 은행원 알고리즘 순서

1. request[i] <= need[i] : 해당 조건 불충족시 오류 <br />
2. request[i] <= available[i] : 해당 조건 불충족시 대기 <br />
3. request[i] 값이 available[i]에 더해지며, need[i]에 request[i] 값이 빠진다. <br />
4. 이런 과정을 모든 프로세스에 대해 반복한 뒤, 모든 finish[i]가 True라면 안정 상태가 된다.

### 단점

프로세스가 시스템에 들어갈 때, 필요한 최대 자원 수를 예측해야 하는데 이를 예측 하기가 어렵고, 해당 알고리즘에 대한 자원 소모량이 증가하게 된다. <br />
프로그램의 수도 고정되어있지 않고, 항상 변하기에 쓰기가 어렵다.
