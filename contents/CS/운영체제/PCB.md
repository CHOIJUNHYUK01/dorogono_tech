# PCB와 컨텍스트 스위칭

`PCB(Process Control Block)`은 운영 체제에서 관리하는 프로세스에 대한 메타 데이터를 저장한 데이터 블록이다. <br />
커널 스택에 저장되고, 각 프로세스가 생성될 때마다 고유의 PCB가 생성된다. <br />
프로세스가 종료되면 제거된다.

**커널 스택** <br />
가상 메모리는 사용자 공간과 커널 공간으로 구분된다. <br />
이 두 가지의 공간 모두 스택 자료 구조를 기반으로 관리되기 때문에, 사용자 스택, 커널 스택이라고도 불린다. <br />
이때 커널 스택은 가상 메모리 주소의 윗부분을 말한다. <br />
예를 들어, 가장 처음 시작하는 주소값이라고 보면 된다. <br />
이 커널 스택은 "커널 모드"에서만 접근할 수 있고, 사용자 스택은 "유저 모드"에서만 접근이 가능하다.

**메타 데이터** <br />
데이터에 관한 구조화된 데이터이자, 데이터를 설명하는 작은 데이터다. <br />
대량의 정보 가운데에서 찾고 있는 정보를 효율적으로 찾아내서 이용하기 위해 일정한 규칙에 따라 콘텐츠에 대해 부여되는 데이터다.

## PCB의 구조

- 프로세스 상태 : <br />
  대기중, 실행 중 등 프로세스의 상태

- 프로세스 번호(PID) : <br />
  각 프로세스 고유 식별 번호

- 프로그램 카운터(PC) : <br />
  이 프로세스에 대해 실행될 다음 명령의 주소에 대한 포인터

- 레지스터 :<br />
  레지스터 관련 정보

- 메모리 제한 : <br />
  프로세스의 메모리 관련 정보

- 열린 파일 정보 : <br />
  프로세스를 위해 열린 파일 목록들

## 컨텍스트 스위칭

이는 앞서 설명한 PCB를 기반으로 프로세스의 상태를 저장하고 다시 복원시키는 과정이다. <br />
프로세스 기준으로 설명하지만, 스레드 또한 가능하다. <br />
이는 프로세스가 종료되거나 인터럽트에 의해 발생된다.

### 비용

1. 유휴 시간의 발생: <br />
   컨텍스트 스위칭을 할 때마다 프로세스 당 유휴 시간이 발생한다.

2. 캐시 미스: <br />
   프로세스가 갖고 있는 메모리 주소가 그대로 있으면, 잘못된 주소 변환이 생긴다. <br />
   그러므로 캐시 클리어 과정이 무조건 일어나고, 이 때문에 캐시 미스가 발생한다.

3. 오버헤드: <br />
   CPU는 중단된 작업의 상태(레지스터, 프로그램 카운터, 메모리 매핑 등)을 저장한다. <br />
   그리고 새 작업의 상태를 로드해야 한다. <br />
   이때 일정한 오버헤드가 발생하는데, 이 오버헤드가 자주 발생하면 전체적으로 시스템 성능이 저하될 수 있다. <br />
   그렇게 되면 CPU의 유효 가동 시간에 영향을 미친다.

### 스레드에서의 컨텍스트 스위칭

스레드는 스택 영역을 제외한 모든 메모리를 공유하기에, 비용이 더 적고, 시간도 더 적게 걸린다는 장점이 있다.

---

## 프로세스 상태

참고로 `ready suspended`와 `blocked suspended`, `blocked`를 묶어서 `waiting` 상태로 표현하기도 한다.

### 생성 상태 (create or new)

이는 프로세스가 생성된 상태를 의미하며, `fork()`, `exec()` 함수를 통해 프로세스가 생성된 상태다. <br />
이때 PCB가 할당된다.

- fork: <br />
  부모 프로세스의 주소 공간을 그대로 복사하며, 새로운 자식 프로세스를 생성하는 함수다.

- exec: <br />
  새롭게 프로세스를 생성하는 함수다.

### 대기 상태 (ready)

처음 프로세스가 생성된 이후, 메모리 공간이 충분하면 메모리를 할당받고, 아니면 아닌 상태로 준비큐(준비 순서열)에 들어가 대기 중인 상태를 말한다. <br />
이는 CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태다.

### 대기 중단 상태 (ready suspended)

준비큐가 꽉찬 상태, 즉 메모리 부족으로 일시 중단된 상태다.

### 실행 상태 (running)

CPU 소유권과 메모리를 할당받고, 인스트럭션을 수행 중인 상태를 의미한다. <br />
이를 `CPU burst`가 일어났다고도 표현한다.

### 중단 상태 (blocked)

어떤 이벤트가 발생한 이후, 기다리며 프로세스가 차단된 상태다. <br />
예를 들어, 프린트 인쇄 버튼을 눌렀을 때, 실행하고 있던 프로세스가 잠깐 멈춘 듯할 때가 있다. <br />
이는 프린트 인쇄에 관한 I/O 요청으로 인해 인터럽트가 발생되어, 현재 실행하고 있던 프로세스가 중단 상태로 잠시 변경된 것이다.

### 일시 중단 상태 (blocked suspended)

대기 중단 상태와 유사하다. <br />
중단된 상태에서 프로세스가 실행되려고 했지만, 메모리 부족으로 일시 중단된 상태다.

### 종료 상태 (terminated or exit)

프로세스 실행이 완료되어, 해당 프로세스에 대한 자원을 반납하고, PCB가 삭제되는 상태다. <br />
종료는 자연스럽게 종료되는 것도 있지만, 부모 프로세스가 자식 프로세스를 강제적으로 종료시켜 비자발적으로 종료(abort) 되기도 한다.

자식 프로세스에 할당된 자원의 한계치를 넘어서거나, 부모 프로세스가 종료되거나, 사용자가 `process.kill` 등 여러 명령어로 프로세스를 종료시킬 때, 발생한다.
