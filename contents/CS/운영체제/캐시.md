# 캐시

데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리다. <br />
이를 통해 데이터 접근 시간의 단축, 데이터를 다시 계산하는 등의 시간을 절약할 수 있다. <br />
캐시의 예는 CPU 레지스터가 대표적인데, CPU가 메모리로부터 데이터를 가져올 때의 시간이 너무나 크기 때문에 그 중간에 레지스터 계층을 둬서 속도 차이를 해결한다.

캐시 히트란, 캐시에서 원하는 데이터를 찾은 것이다. <br />
캐시 미스란, 캐시에서 원하는 데이터를 찾지 못한 것이다. <br />
앞의 예시 같은 경우는 캐시 미스가 일어나면, 메모리로 가서 원하는 데이터를 레지스터에 등록하게 된다.

참고로 이러한 캐시는 우리가 사용하는 서비스 내부에서도 많이 찾아볼 수 있다. <br />
데이터 베이스에서 redis 데이터베이스를 캐시 계층으로 둔 사례가 그러하다. <br />
웹 서버 앞단에 nginx 서버를 캐시 계층으로 둔 것도 마찬가지다.

## 지역성의 원리

캐시를 설정할 때는 자주 사용하는 데이터를 기반으로 설정해야 한다. <br />
이때 지역성을 기반으로 설정되는데, 지역성은 시간 지역성과 공간 지역성으로 나뉜다.

### 시간 지역성

최근 사용한 데이터에 다시 접근하려는 특성이다.

### 공간 지역성

최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성을 말한다.

```javascript
let arr = Array.from({ length: 10 }, () => 0);
console.log(arr);
for (let i = 0; i < 10; i += 1) {
  arr[i] = i;
}
/*
[
console.log(arr)
0, 0, 0, 0, 0,
0, 0, 0, 0, 0
]
[
0, 1, 2, 3, 4,
5, 6, 7, 8, 9
]
*/
```

위 코드를 보면, 최근 사용한 변수 i에 대해 계속해서 1을 더하는 걸 볼 수 있다. (시간 지역성) <br />
최근 사용했던 공간인 arr라는 배열에 i가 할당되며, 연속적으로 접근하는 걸 볼 수 있다. (공간 지역성)

---

## 캐시 매핑

캐시의 크기는 메모리보다 항상 작기에, 효율적으로 매핑하는 것이 중요하다. <br />
매핑 방식에는 직접 매핑, 연관 매핑, 집합 - 연관 매핑이 있다. <br />
참고로 직접 사상, 연관 사상, 집합 - 연관 사상이라고도 한다.

### 직접 매핑

> 직접 블록별 매핑을 한다.

메모리의 특정 블록은 특정 캐시 라인에만 매핑할 수 있는 것을 말한다. <br />
예를 들어, 메모리가 A개의 페이지, 캐시가 B개의 페이지로 구성된다고 했을 때, 메모리의 페이지 수 A를 B개로 나누는 것이다. <br />
이렇게 되면 메모리의 페이지 수는 B \* 블록의 수가 된다. <br />
메모리가 1 ~ 100이 있고, 캐시가 1 ~ 5가 있다고 해보자. <br />
그러면 1 : 1~20, 2 : 21~40... 이런 식으로 매핑하는 것이다.

내부적으로 어떻게 구성되어있을까? <br />
운영 체제는 메모리를 똑같은 크기의 페이지(보통 4kb)로 나눠 관리한다. <br />
`<P, D>`로 나눠 관리한다. <br />
P는 페이지 번호, D(Page Offset)은 페이지 번호로부터 해당 주소까지의 거리를 의미한다.

가상 주소는 20bits로, 주소를 관리하기에 더 많은 주소를 할당하는 것을 볼 수 있다. <br />
이런 주소가 16bits의 실제 주소로 페이지 테이블을 통해 변환된다. <br />
여기서 D는 변환되지 않는다. 변환되는 것은 P다.

즉, 매핑되는 부분은 P이기에, P만 보면 된다. <br />
P를 직접 매핑에서는 `{tag, bd}`로 세분화해서 직접 매핑을 구현한다. <br />
여기서 bd, 블록을 위한 태그를 기반으로 `<tag, bd, D>`로 세분화해서 bd가 같은 라인만 매핑이 되게 한다.

이를 통해 해당 블록만 확인하면 되기에 처리가 빠른 장점이 있다. <br />
하지만 스와핑이 빈번하게 발생할 수 있다.

### 연관 매핑

> 자유로이 연관 매핑을 한다.

순서를 일치시키지 않고, 관련 있는 캐시와 메모리를 매핑한다. <br />
그래서 메모리의 컨텐츠가 캐시의 어느 위치에도 올라갈 수 있다. <br />
이러면 스와핑은 덜 일어나지만, 캐시의 모든 블록을 탐색해야 하기에 속도가 직접 매핑보다 느리다. <br />
여기서는 bd와 tag를 합친 P를 기준으로 한다.

### 직접 - 연관 매핑

집합을 나누고(정해진 집합을 만드는 건, 직접 매핑), 해당 집합에는 bd만 같으면 들어올 수 있게 한다. <br />
이때 어떤 블록에도 들어올 수 있게 하는 것이다. <br />
이를 통해 모든 블록을 찾을 필요없이 특정 블록을 찾게 해, 탐색 비용을 낮춘 직접 매핑의 장점과 스와핑을 완화시키는 연관 매핑의 장점을 모두 지닌다.

예를 들어, 캐시에서 bd가 0인 집합을 2개로 나누고, bd가 같은 것만 들어올 수 있게 한다. <br />
bd가 많지만, bd를 0 또는 1 밖에 없게 해서 집합을 두 개로 나눈다. <br />
bd가 0인 것이 2개, 1인 것이 2개가 들어갈 수 있게 나눈 것이다.
