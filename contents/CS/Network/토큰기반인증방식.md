# 토큰 기반 인증 방식

state를 모두 토큰 자체만으로 처리한다. <br />
토큰을 처리하는 한 서버를 두고, 다른 콘텐츠를 제공하는 서버는 모두 stateless하게 만들자는 이론이 담긴 방식이다.

왜 토큰을 관리하는 서버를 따로 둬야 할까? <br />
이는 여러 개의 서버를 운용할 때, 토큰 기반 인증 + A 도메인을 처리하는 서버로 구축하는 걸 예로 들자. <br />
A 도메인에서 에러가 발생되면, 인증에 관한 기능이 마비된다. <br />
연쇄적으로 B, C, D 등의 도메인 기능이 마비될 수도 있기 때문이다.

토큰은 주로 `JWT 토큰`이 활용된다. <br />

1. 인증로직 >> JWT 토큰 생성 (access, refresh 토큰) <br />
2. 사용자가 이후에 access 토큰을 `HTTP Header - Authorization` 또는 `HTTP Header - Cookie`에 담아 인증이 필요한 서버에 요청해 원하는 컨텐츠를 가져온다.

## JWT 토큰이란?

`JSON Web Token`을 의미한다. <br />
헤더, 페이로드, 서명으로 이뤄져 있다. <br />
JSON 객체로 인코딩되며, 메시지 인증과 암호화에 사용된다.

HEADER : 토큰 유형과 알고리즘, base64URI로 인코딩된다.

```javascript
{
    "alg": "HS246",
    "typ": "JWT"
}
```

Payload : 데이터, 토큰 발급자, 토큰 유효기간, base64URI로 인코딩된다.

```javascript
{
    "sub": "1234",
    "name": "JOHN",
    "admin": true,
    "iat": 1236719785623895
}
```

Signature : 인코딩된 header + payload + 비밀키를 기반으로 헤더에 명시된 알고리즘으로 다시 생성한 서명값

```
Base64URLSafe(
    HMACSHA256(
        <header>.<payload>,
        <secret key>
    )
)
```

[JWT 인코딩/디코딩 사이트](https://jwt.io/)

### 장점

1. 사용자 인증에 필요한 모든 정보는 토큰 자체에 포함하기에, 별도의 인증 저장소가 필요없다. <br />
2. 다른 유형의 토큰과 비교했을 때, 경량화되어있다. SAML이란 토큰이 있지만, 이에 비해 훨씬 경량화되어있다. <br />
3. 디코딩했을 때, JSON이 나오기에, JSON을 기반으로 쉽게 직렬화, 역직렬화가 가능하다.

### 단점

1. 토큰이 비대해질 경우, 당연히 서버 과부화에 영향을 준다. <br />
2. 토큰을 탈취당할 경우, 디코딩했을 때 데이터를 볼 수 있다.

---

## 구현 방식

refresh 토큰과 access 토큰 두 개를 기반으로 만든다. <br />
access 토큰은 수명을 짧게, refresh 토큰은 길게 만든다.

refresh 토큰은 access 토큰이 만료됐을 때, 다시 access 토큰을 얻기 위해 사용된다. <br />
이를 통해, access 토큰이 만료됐을 때마다 인증에 관한 비용이 줄어든다. <br />
로그인을 하게 되면, 이 두 토큰을 얻는다.

### 주의할 점

access 토큰을 얻었다면, 그 이후에 요청을 할 때는 `HTTP Header - Authorization` 또는 `HTTP Header - Cookie`에 담아 요청한다. <br />
이때 다음과 같은 규칙을 지키는 것이 좋다.

- `Bearer <token>` 으로 Bearer을 앞에 둬서 토큰 기반 인증 방식이라는 걸 알려줘야 한다. <br />
- `https`를 사용해야 한다. <br />
- 쿠키에 저장한다면 `sameSite: 'Strict'`을 써야 한다. <br />
- 수명이 짧은 access token을 발급해야 한다. <br />
- url에 토큰을 전달하지 말아야 한다.

이러한 점들은 `OAuth2.0`과 `JWT`에 관한 표준문서인 RFC 6750, RFC 7519를 기반으로 한다.

### 토큰 탈취 대비 방법

1. 먼저 `access token`의 수명을 짧게 설정해 탈취된 토큰 유효 기간을 최소화한다. <br />
   `짧은 수명의 access token을 사용`하고, `필요할 떄만 refresh token`을 통해 `새로운 access token을 발급`받는다.

2. `refresh token`을 사용해 민감한 작업을 수행하려고 할 때, 추가적인 사용자 인증 단계를 요구한다. <br />
   예를 들어, IP주소, 디바이스 정보 등을 이용하거나, google authentifactor를 이용한 2단계 인증을 사용한다.

3. 쿠키에 `HttpOnly` 및 `Secure`을 걸어 관리한다.

---

## 협업에서의 토큰 및 쿠키 - 세션 사례

사실 어떤 사이트가 토큰 기반인지, 세션 기반인지 명확하게는 모른다. <br />
그러나 보통 토큰 기반 인증 방식을 사용한다면, 해당 토큰 값의 네이밍을 접두사가 `token` 또는 `bearer`로 시작하는 경우가 있다. <br />
아니면 토큰 이름을 `token`이라는 걸 넣어, 해당 사이트가 토큰 기반 인증 방식임을 유추할 수 있다.

로그인에 관한 정보를 쿠키에 담아 관리할 때, 네이밍을 흔한 `session_id` 혹은 `access_token` 등을 쓰지 않는다. <br />
대신 기업 내에서 정한 이름을 바탕으로 관리하며, 쿠키를 나눠 관리하는 사례도 있다.
