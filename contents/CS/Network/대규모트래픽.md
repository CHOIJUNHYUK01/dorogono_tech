# 대규모 트래픽으로 인한 서버 과부하 해결 방법

## 서버 과부하란

서버가 리소스를 소진해 들어오는 요청을 처리하지 못할 때 발생한다. <br />
이때 서버는 사용자의 웹 요청을 처리하지 못해 "응답없음"이 뜨게 된다. (5XX 에러)

## 모니터링을 통한 자원 할당

사실 이러한 서버 과부하로 서버가 "응답없음"이 뜨는 것은 여러가지 이유가 있다. <br />
그 중 하나가 바로 "자원의 한계점 도달"이다. <br />
보통 서버의 CPU 사용량이 80-90%에 도달하거나, 메모리가 부족해 계속해서 스와핑이 발생하면 과부화 상태가 된다.

이는 **모니터링을 통한 자원의 적절한 할당**으로 해결한다. <br />
자원은 CPU, 메모리, 대역폭도 포함된다.

### AWS 오토스케일링

이는 서비스 이용 불가능 상태 발생 이전에 `cloud watch`가 계속해서 모니러링해서 서버 대수를 늘려주는 방법이다. <br />
애플리케이션을 자동으로 모니터링하고 자원의 용량으 자동으로 조정한다.

### netdata를 이용한 모니터링

AWS를 사용하지 않을 때, 무료 모니터링 서비스다. <br />
이를 기반으로 지속적인 모니터링과 자우너할당을 해서 해결할 수도 있다.

모니터링 대시보드를 구축하지 않고도, slack과 연동해서 알림 서비스를 구축할 수도 있다.

### 모니터링을 왜 할까?

먼저 서버 과부하로 인해 서버 중지에 대한 대처를 할 수 있다.

1. 어떤 페이지에 어떤 트래픽이 얼마나 발생했는지 <br />
2. 어떤 네트워크에서 병목 현상이 일어났는지

등을 모니터링을 통해서 알 수 있다. <br />
모니터링을 하면, 활용도가 낮은 페이지와 높은 페이지를 파악할 수 있다. <br />
그래서 나중에 서비스 개선에도 도움이 된다.

즉, 해결하기 위한 문제점을 파악하기 위해 모니터링은 필수적이다. <br />
또한 일부 서비스는 모니터링한 결과물을 알려주면서, 서비스의 중단 등의 여부를 사용자에게 알려주기도 한다.

### 로드밸런서

AWS 오토 스케일링은 빠르긴 하나, 구성에 시간이 걸린다. <br />
그래서 앞단에 로드밸런서를 통해 트래픽을 분산해야 한다.

이는 한 서버에 장애가 발생하면, 트래픽을 다른 기능 서버로 리다이렉션하여 시스템 중단을 방지할 수 있다.

### 블랙스완 프로토콜

블랙스완은 예측할 수 없는 사고가 일어난 것을 말한다. <br />
사후에는 이 사고의 원인 등을 분석할 수 있지만, 사전에는 이 사고를 예측할 수 없는 것을 말한다.

중요한 건, 이러한 블랙스완은 매번 일어나기에 대비를 해야 한다. <br />
구글은 다음과 같은 수칙을 따른다.

1. 영향을 받은 시스템과 각 시스템의 상대적 위험 수준을 확인한다. <br />

   - 체계적으로 데이터를 수집하고, 원인에 대한 가설을 수립하고 테스팅한다.

2. 잠재적으로 영향을 받을 수 있는 내부의 모든 팀에 연락한다.

3. 최대한 빨리 취약점에 영향을 받는 모든 시스템을 업데이트한다.

4. 복원 계획을 포함한 우리의 대응 과정을 파트너와 고객 등 외부에 전달한다.

서비스를 운영한다면, 이런 규칙을 정하는 게 좋다.

---

## 서킷 브레이커

서킷 브레이커 패턴이라고도 불린다. <br />
서비스 장애를 감지하고, 연쇄적으로 생기는 에러를 방지하는 기법이다. <br />
서비스와 서비스 사이에 서킷 브레이커 계층을 두고, 미리 설정한 `timeout 임계값`에 도달하면 서킷 브레이커가 그 이후의 추가 호출에는 무조건 에러를 반환하게 한다.

### 필요한 사례 : 스레드의 차단

하나의 스레드가 차단되는 건 괜찮다. <br />
만약 100개의 스레드가 있고, 그중 98개의 요청이 에러가 있는 서비스에 요청하면, 나머지 2개의 요청은 차단되는 거다.

### 필요한 사례 : 계단식 실패 발생

서비스 A에 장애가 난다면, 이어져있는 B, C, D 서비스의 응답도 지연된다. <br />
이를 계단식 실패라고 한다.

하나 이상의 부품, 서비스 등의 고장이 연결된 다른 부품이나 서비스의 고장으로 이어지는 것을 말한다.

> 사용자 입장에서 응답을 오래 기다려야 하는 건, 좋은 UX가 아니다. <br />
> 성공인지, 실패인지는 중요하지 않다. <br />
> 중요한 건, 사용자가 기다리지 않아야 하는 것이다.

---

## 서킷 브레이커의 상태

서킷 브레이커는 `closed`, `open`, `half_open`의 상태값을 가진다.

- closed[정상]: 네트워크 요청의 실패율이 임계치보다 낮다.

- open[에러]: 임계치 이상의 상태를 말한다. 요청을 서비스로 전송하지 않고 바로 오류를 반환한다. 이를 `fail fast`라 한다.

- half_open[확인중]: `open` 상태에서 일정 `timeout`으로 설정된 시간이 지나면, 장애가 해결됐는지 확인하기 위해 이 상태가 된다. <br />
  여기서 요청을 전송해 응답을 확인한다. 장애가 풀렸다면, `closed`로 변경하고, 아니라면 다시 `open` 상태가 된다.

### 장점

연속적인 에러 발생을 막아주며, 일부 서비스가 종료되더라도 다른 서비스들은 이상없이 동작하게 만들 수 있다. <br />
그래서 사용자 경험을 높일 수 있다.

---

## 컨텐츠 관리

1. 불필요한 컨텐츠, 쿼리 등을 제거한다.

2. CDN을 통한 컨텐츠 제공 <br />
   CDN을 통해 사용자 가까이, 그리고 분산된 대규모 서버 네트워크를 기반으로 컨텐츠를 제공해서 메인 서버에 대한 부하를 줄인다.

3. 컨텐츠 캐싱 <br />
   네트워크 트래픽을 해결하는 가장 좋은 방법은 해당 트래픽이 발생하지 않도록 하는 거다. <br />
   브라우저 캐시를 통해 해당 요청에 관한 항목을 캐시에서 응답을 읽어, 네트워크 요청에 관한 비용을 모두 제거한다.

4. 컨텐츠 압축 <br />
   텍스트 기반 리소스는 `gzip` 또는 `Brotli`를 통해 압축해야 한다. <br />
   압축하면 70% 정도까지 압축할 수 있다. <br />
   다만 압축했기 떄문에 압축을 풀기 위해 서버에서 자원을 사용하는 양까지 고려해야 한다. <br />
   보통은 압축하면 좋다.

5. 컨텐츠의 우아한 저하 (미리 준비된 응답) <br />
   시스템의 과도한 부하를 줄이기 위해 제공하는 컨텐츠 및 기능을 일시적으로 줄이는 전략이다. <br />
   예를 들어, 정적 텍스트 페이지를 제공하거나, 검색을 비활성화하거나, 더 적은 수의 검색 결과를 반환하거나, 필수적이지 않은 기능을 비활성화한다.
