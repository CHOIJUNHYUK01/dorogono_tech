# HTTPS와 TLS

## 암호화

승인된 당사자만 정보를 이해할 수 있도록 데이터를 **스크램블**한 방법이다. <br />
이를 복호화하려면, 송신자와 수신자가 서로 동의한 **키**가 필요하다. <br />
또한 이를 만들기 위해 키가 쓰이기도 한다. <br />
`ciphertext = plaintext + key`

### 스크램블

각 단어나 문자를 패턴에 따라 암호화하는 것이 아니다. <br />
무작위 방식으로 개별 데이터 비트를 섞는 것이다.

예를 들어, 공통 128비트 고급 암호화 표준(AES)으로 암호화된 파일의 경우에는 이 파일을 구성하는 비트는 약 10회 스크램블된다. <br />
다른 컴퓨터가 키없이 해독하려면 아주 오랜 시간이 걸린다. <br />
비트가 높아질수록 스크램블을 많이 하게 되고, 더 복잡해지는 것이다. <br />
이 128비트는 AES의 가장 약한 버전이다. <br />
192비트 및 256비트 키 크기도 제공한다.

### 대칭 암호화

키를 하나만 사용하는 암호화 방법이다. <br />
예를 들어, "hello"라는 텍스트를 키로 암호화한다고 해보자. <br />
동일한 키로 암호를 해독해서 "hello"를 반환한다.

> Plaintext + key = cipertext: hello + 2jd8932kd8 = X5xJCSycg14= <br />
> Ciphertext + key = plaintext: X5xJCSycg14= + 2jd8932kd8 = hello

일반적으로 사용되는 대칭 암호화 알고리즘은 `DES`와 `AES`가 있다.

### 비대칭 암호화

공개키 암호화라고도 한다. <br />
공개키 암호화는 두 개의 다른 키가 있다. 공개키, 개인키가 있다. <br />
이를 활용해 데이터를 암호화하거나 서명하고, 키 중 하나인 공개키를 누구나 사용할 수 있도록 한다. <br />
공개키로 암호화된 데이터는 개인키로만 복호화할 수 있게 한다. <br />
일반적으로 사용되는 비대칭 암호화 알고리즘은 `RSA`, `DH(Diffie-Hellman)`이 있다.

HTTP를 가능하게 하는 프로토콜인 `TLS`는 부분적으로 비대칭 암호화를 사용한다. <br />
비대칭 암호화로 인증을 한 후에 대칭 암호화로 보안적 통신을 시작한다.

`TLS 핸드셰이크`과정에서 처음 인증할 때, 비대칭 암호화를 한다. <br />
이후 클라이언트와 서버는 "세션키"라고 하는 키를 기반으로 대칭 암호화를 기반으로 암호화된 통신을 한다.

### 암호화의 필요성

암호화는 의도된 수신자 또는 송신자를 제외하고는 통신을 하이재킹해서 읽을 수 없게 한다. <br />
이를 통해 민감한 데이터의 유출을 방지하고 데이터 무결성을 보장한다.

---

## TLS 핸드셰이크

`SSL(Secure Socket Layer)`은 SSL 1.0부터 시작해서 SSL 2.0, SSL 3.0, TLS 1.0 - 1.3까지 버전이 올라가며, 마지막으로 TLS로 명칭이 변경됐다. <br />
TLS는 전송 계층에서 보안을 제공하는 프로토콜이다. <br />
클라이언트와 서버가 통신할 때, TLS를 통해 제 3자가 메시지를 도청하거나 변조하지 못하도록 한다.

사용할 TLS 버전을 정하고, 사이퍼슈트, 서버의 공개키, SSL인증서를 기반으로 인증 작업을 수행한다. <br />
이후 대칭 암호화를 위해 세션키를 생성한다.

1. Client Hello <br />
   클라이언트는 TLS 버전, 사이퍼슈트와 클라언트 랜덤값(무작위 문자열), 임시 DH 매개변수를 서버로 보낸다.

2. Server Hello, EncryptedExtensions, Certificate, CertificateVerify <br />
   서버는 클라이언트로부터 받은 옵션을 확인한다. <br />
   서버와 클라이언트 모두에서 지원하는 가장 높은 TLS 버전을 식별해 결정한다. <br />
   사이퍼슈트 지원 여부도 확인한다. <br />
   공개키가 포함된 SSL 인증서, 서버 랜덤값, 임시 DH 매개변수를 보낸다. <br />
   그리고 클라이언트와 서버 각각 교환한 DH 매개변수를 사용해 임시 암호 키(세션키)를 생성한다.

   Server Hello : 서버는 클라이언트가 제공한 키교환 매개변수를 기반으로 자신의 키 교환 매개변수를 생성하고, 이를 클라이언트에게 전송한다.

   Encrypted Extensions : 필요한 추가 확장 정보를 암호화된 형태로 교환한다.

   Certificate : 서버는 자신의 인증서를 클라이언트에게 전송한다. 이 인증서에는 서버의 공개키가 포함되어 있다. 이를 통해 서버의 신원을 검증할 수 있다.

   Certificate Verify : 서버는 자신의 개인키를 사용해 생성된 디지털 서명을 전송한다. 제공된 인증서의 유효성과 서버의 소유권을 증명한다.

3. Finished <br />
   서버와 클라이언트 모두 이전에 교환된 모든 메시지에 대한 무결성과 인증을 확인하는 메시지를 보낸다. <br />
   그러면 클라이언트와 서버와 세션키를 기반으로 대칭 암호화된 통신이 시작된다. <br />
   보안 세션이 시작됐다고도 말한다. <br />
   키교환 알고리즘으로는 대표적으로 `RSA`와 `DH`가 있다. <br />
   TLS 1.3에서는 `RSA`같은 경우, 취약점이 있기 때문에 공식적으로 지원하지 않는다. <br />
   DH의 경우, 타원곡선 DH를 사용한다.

## DH 매개변수

Diffie-Hellman을 의미한다. <br />
이 알고리즘은 서로 공개값 공유, 비밀값과 혼합, 혼합값과 공유, 각자의 비밀값과 혼합해서 공통의 암호키를 만드는 알고리즘이다.

DH는 그냥 디피헬만을 사용하는 `DHE`와 타원 곡선 암호화 방법과 DH를 섞은 `ECDHE`가 있고, 보통 `ECDHE`를 쓴다.

### 타원 곡선 암호화 방법

곡선을 사용해 개인키 보유자만 알 수 있는 타원 곡선을 그린다. <br />
이를 기반으로 교차점을 생성한다. <br />
이 교차점의 수를 기반으로 암호를 설정한다.

## 사이퍼 슈트

이는 프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약이다. <br />
암호제품군이라고도 부른다.<br />
TLS1.3에는 다섯 개가 있다.

예를 들어, `TLS_AED_128_GCM_SHA256`이 있다. <br />
여기에는 세 가지 규약이 있다.

1. TLS : 프로토콜 <br />
2. AES_128_GCM : AEAD 사이퍼 모드 <br />
3. SHA256 : 해싱 알고리즘

### AEAD 사이퍼 모드

Authenticated Encryotion with Associated Data는 데이터 암호화 알고리즘이다. <br />
그 중에 `AES_128_GCM`이 있다. <br />
예를 들어 `AES_128_GCM`은 128비트의 키를 사용하는 표준 블록 암호화 기술과 병렬 계산에 용이한 암호화 알고리즘인 `GCM`이 결합된 알고리즘이다.

### 해싱 알고리즘

데이터를 추정하기 힘든 더 작고, 섞여 있는 조각으로 만드는 알고리즘이다. <br />
SSL/TLS는 해싱 알고리즘으로 `SHA-256` 알고리즘과 `SHA-384` 알고리즘을 사용한다. <br />
이 중에서 `SHA-256`을 많이 사용한다. <br />
이는 해시 함수의 결과값이 "256비트"인 알고리즘이다. <br />
비트코인을 비롯한 많은 블록체인 시스템에서도 쓴다.

- 해싱 알고리즘은 TLS에서 어떻게 쓰이나?
  인증서가 올바른 인증서인지 확인할 때, 전자서명을 이용하는데, 이때 사용한다. <br />

  인증 생성작업 : 전자 서명을 만드는데 서명되는 메시지를 해싱한다. <br />
  인증 확인작업 : 메시지를 복호화해서 해시를 서로 비교해 올바른지 확인한다.

  전자 서명이라 함은 송신자가 자신의 신원을 증명하는 절차 또는 정보다. <br />
  프로그램 안에 제작자 표시를 할 수 있는데, 이를 쉽게 조작하지 못하도록 기술적인 장치를 기반으로 되어 있다. 이게 전자 서명이다.

  이 전자 서명을 통해 인증서에 적힌 주체가 "서비스 제공자"인지 확인한다. <br />
  인증서에 기록된 전자 서명을 기반으로 CA의 공개키로 복호화해서 지문을 얻고, 인증서에 기록된 정보들을 해시 함수에 입력해 해시를 얻어, 두 해시의 일치 여부를 확인한다. <br />
  이를 통해 두 지문이 일치하면, 인증서 자체가 변조된 적이 없다는 걸 의미한다. <br />
  이를 통해 인증서의 유효성을 검증할 수 있는 것이다. <br />
  즉, 유효성 검증이란 인증서가 변조되지 않았고, 인증서가 "서비스 제공자"것임을 확인하는 절차다.

### 인증서

1. 주체 (인증서를 발급한 CA, 도메인, 우베사이트 소유자, 인증서 소유자) <br />
2. 공개키 (공개키, 공개키 암호화 방법)을 포함하는 단순한 데이터 파일 <br />
   자신의 웹사이트 안에서 SSL 인증서를 만들 수도 있지만, 보통 인증기관(CA)에서 발급한 SSL인증서를 기반으로 인증 작업을 수행한다. <br />

주체는 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지 확인할 때 쓰인다. <br />
공개키는 처음 인증작업을 수행할 때 쓰인다.

### CA

인증서의 역할은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지 보장하는 역할을 한다. <br />
이 인증서를 발급하는 기업들을 CA(Certificate Authority)라고 한다. <br />
참고로 서비스의 도메인, 공개키와 같은 정보는 서비스가 CA로부터 인증서를 구입할 때 제출해야 한다. <br />
인증서는 다양한 유형의 인증서가 있다.

- 단일 도메인 : 단 하나의 도메인에 적용되는 인증서 <br />
- 와일드카드 : 도메인의 하위 도메인도 포함하는 인증서 <br />
- 멀티 도메인 : 이름이 의미하는 것처럼 멀티 도메인 SSL 인증서는 관련되지 않은 다수의 도메인에 적용될 수 있는 인증서

### RSA의 취약점

클라이언트가 생성한 임시 암호값을 서버로 전송한다. <br />
하지만 DH는 클라이언트와 서버가 서로 교환한 DH 매개변수를 사용해 개인키를 만든다. <br />
이 때문에 RSA는 클라이언트에서 생성한 임시 암호값이 탈취당하면, 해킹의 위험이 있다. <br />
그러나 DH의 경우, 탈취당해도 공통의 암호키를 만들지 못하기에 더 좋은 거다.

### 0-RTT

세션키가 생성된 이후, 다시 그 사이트에 방문하면 미리 만들어놓은 세션키 (PSK, pre-shared key)를 기반으로 연결을 생성하기에, 인증에 드는 비용은 없다. <br />
즉, 인증에 관한 RTT가 발생하지 않는다.

- 왜 네트워크 상 보안을 해야 하나?<br />
  신용카드 등 민감한 금융 정보를 다루는 데 이점이 있다. <br />
  HTTP/2를 구현할 수 있다. <br />
  HTTP/2는 보통 HTTPS 위에서만 돌아간다. <br />
  TLS 계층을 선택적으로 쓸 수 있지만, 보통은 HTTP/2를 쓸 때, TLS 계층을 둔다.

- 웹사이트가 SSL을 잘 수행하는지는 어떻게 아는가?<br />
  [확인 사이트](https://www.ssllabs.com/ssltest/)
  참고로 구글도 B다. B면 괜찮다.
